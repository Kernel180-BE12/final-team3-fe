# P08. 테스팅 전략 및 품질보증

## 📋 개요

JOBER 프로젝트의 테스트 전략과 품질 보증 체계를 정의하여 안정적이고 신뢰할 수 있는 애플리케이션을 제공합니다.

### 목적
- 체계적인 테스트 전략 수립
- 품질 보증 프로세스 정의
- 자동화된 테스트 환경 구축
- 코드 품질 향상 방안 제시

## 🎯 테스트 전략 개요

### 테스트 피라미드

```
              🔺 E2E Tests (5%)
            🔺🔺 Integration Tests (15%)
        🔺🔺🔺🔺 Unit Tests (80%)
```

#### 1. 단위 테스트 (Unit Tests) - 80%
- **목표**: 개별 함수/컴포넌트 검증
- **도구**: Jest, React Testing Library
- **커버리지**: 최소 80% 이상
- **실행 시간**: 빠름 (< 10초)

#### 2. 통합 테스트 (Integration Tests) - 15%
- **목표**: 컴포넌트 간 상호작용 검증
- **도구**: Jest, React Testing Library, MSW
- **커버리지**: 주요 사용자 플로우
- **실행 시간**: 보통 (< 30초)

#### 3. E2E 테스트 (End-to-End Tests) - 5%
- **목표**: 전체 사용자 시나리오 검증
- **도구**: Playwright, Cypress
- **커버리지**: 핵심 비즈니스 플로우
- **실행 시간**: 느림 (< 5분)

## 🧪 단위 테스트 (Unit Testing)

### 1. React 컴포넌트 테스트

#### 기본 컴포넌트 테스트 구조
```jsx
// components/BackButton/BackButton.test.jsx
import { render, screen, fireEvent } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import BackButton from './BackButton';

// 테스트 헬퍼 함수
const renderWithRouter = (component) => {
  return render(
    <BrowserRouter>
      {component}
    </BrowserRouter>
  );
};

describe('BackButton', () => {
  test('기본 렌더링 테스트', () => {
    renderWithRouter(<BackButton />);

    expect(screen.getByText('뒤로가기')).toBeInTheDocument();
    expect(screen.getByRole('button')).toBeInTheDocument();
  });

  test('커스텀 텍스트 표시', () => {
    renderWithRouter(
      <BackButton>이전 단계로</BackButton>
    );

    expect(screen.getByText('이전 단계로')).toBeInTheDocument();
  });

  test('커스텀 onClick 핸들러 호출', () => {
    const mockClick = jest.fn();

    renderWithRouter(
      <BackButton onClick={mockClick} />
    );

    fireEvent.click(screen.getByRole('button'));
    expect(mockClick).toHaveBeenCalledTimes(1);
  });

  test('키보드 접근성 (Enter 키)', () => {
    const mockClick = jest.fn();

    renderWithRouter(
      <BackButton onClick={mockClick} />
    );

    const button = screen.getByRole('button');
    fireEvent.keyDown(button, { key: 'Enter', code: 'Enter' });
    expect(mockClick).toHaveBeenCalledTimes(1);
  });
});
```

#### 복잡한 컴포넌트 테스트 (PricingCard)
```jsx
// components/pricing/PricingCard.test.jsx
import { render, screen, fireEvent } from '@testing-library/react';
import PricingCard from './PricingCard';

const mockPlan = {
  id: 'pro',
  displayName: 'Pro',
  description: '전문가용 플랜',
  priceText: '₩29,900',
  billing: '월 단위 결제',
  color: 'orange',
  badge: '인기',
  features: [
    { name: '월 템플릿 생성', included: true, value: '200개' },
    { name: 'AI 고급 기능', included: true },
    { name: '팀 협업', included: false }
  ],
  highlights: ['가장 인기 있는 플랜']
};

describe('PricingCard', () => {
  test('플랜 정보 정확한 표시', () => {
    render(
      <PricingCard
        plan={mockPlan}
        currentPlan="free"
        onUpgrade={jest.fn()}
      />
    );

    expect(screen.getByText('Pro')).toBeInTheDocument();
    expect(screen.getByText('₩29,900')).toBeInTheDocument();
    expect(screen.getByText('월 단위 결제')).toBeInTheDocument();
    expect(screen.getByText('인기')).toBeInTheDocument();
  });

  test('기능 목록 올바른 표시', () => {
    render(
      <PricingCard
        plan={mockPlan}
        currentPlan="free"
        onUpgrade={jest.fn()}
      />
    );

    // 포함된 기능
    expect(screen.getByText('월 템플릿 생성 (200개)')).toBeInTheDocument();
    expect(screen.getByText('AI 고급 기능')).toBeInTheDocument();

    // 포함되지 않은 기능
    expect(screen.getByText('팀 협업')).toBeInTheDocument();

    // 체크마크/X 아이콘 확인
    const checkIcons = screen.getAllByTestId('check-icon');
    const xIcons = screen.getAllByTestId('x-icon');
    expect(checkIcons).toHaveLength(2);
    expect(xIcons).toHaveLength(1);
  });

  test('현재 플랜 상태 처리', () => {
    render(
      <PricingCard
        plan={mockPlan}
        currentPlan="pro" // 현재 플랜
        onUpgrade={jest.fn()}
      />
    );

    expect(screen.getByText('현재 사용 중')).toBeInTheDocument();
    expect(screen.getByText('현재 플랜')).toBeInTheDocument();

    // 업그레이드 버튼이 비활성화되어야 함
    const button = screen.getByRole('button');
    expect(button).toBeDisabled();
  });

  test('업그레이드 버튼 클릭 핸들러', () => {
    const mockUpgrade = jest.fn();

    render(
      <PricingCard
        plan={mockPlan}
        currentPlan="free"
        onUpgrade={mockUpgrade}
      />
    );

    fireEvent.click(screen.getByText('업그레이드'));
    expect(mockUpgrade).toHaveBeenCalledWith('pro');
  });

  test('추천 플랜 스타일링', () => {
    const { container } = render(
      <PricingCard
        plan={mockPlan}
        currentPlan="free"
        onUpgrade={jest.fn()}
        featured={true}
      />
    );

    const card = container.firstChild;
    expect(card).toHaveClass('featured-plan'); // CSS 클래스 확인
  });
});
```

### 2. Hook 테스트

#### 커스텀 Hook 테스트 (useAuth)
```jsx
// hooks/useAuth.test.js
import { renderHook, act } from '@testing-library/react';
import { useAuth } from './useAuth';

// Mock API calls
jest.mock('../utils/api', () => ({
  login: jest.fn(),
  logout: jest.fn(),
  getCurrentUser: jest.fn()
}));

describe('useAuth', () => {
  beforeEach(() => {
    // 각 테스트 전에 localStorage 클리어
    localStorage.clear();
    jest.clearAllMocks();
  });

  test('초기 상태 확인', () => {
    const { result } = renderHook(() => useAuth());

    expect(result.current.user).toBeNull();
    expect(result.current.isAuthenticated).toBe(false);
    expect(result.current.loading).toBe(false);
  });

  test('로그인 성공 시나리오', async () => {
    const mockUser = { id: 1, email: 'test@example.com', name: '테스트' };
    const { login } = require('../utils/api');
    login.mockResolvedValue({ user: mockUser, token: 'mock-token' });

    const { result } = renderHook(() => useAuth());

    await act(async () => {
      await result.current.login('test@example.com', 'password');
    });

    expect(result.current.user).toEqual(mockUser);
    expect(result.current.isAuthenticated).toBe(true);
    expect(localStorage.getItem('authToken')).toBe('mock-token');
  });

  test('로그인 실패 시나리오', async () => {
    const { login } = require('../utils/api');
    login.mockRejectedValue(new Error('Invalid credentials'));

    const { result } = renderHook(() => useAuth());

    await act(async () => {
      try {
        await result.current.login('test@example.com', 'wrong-password');
      } catch (error) {
        expect(error.message).toBe('Invalid credentials');
      }
    });

    expect(result.current.user).toBeNull();
    expect(result.current.isAuthenticated).toBe(false);
  });

  test('로그아웃 기능', async () => {
    const { result } = renderHook(() => useAuth());

    // 먼저 로그인 상태로 설정
    act(() => {
      result.current.setUser({ id: 1, email: 'test@example.com' });
    });

    await act(async () => {
      await result.current.logout();
    });

    expect(result.current.user).toBeNull();
    expect(result.current.isAuthenticated).toBe(false);
    expect(localStorage.getItem('authToken')).toBeNull();
  });
});
```

### 3. 유틸리티 함수 테스트

#### API 유틸리티 테스트
```jsx
// utils/api.test.js
import { fetchTemplates, createTemplate, updateTemplate } from './api';

// fetch 모킹
global.fetch = jest.fn();

describe('API Utils', () => {
  beforeEach(() => {
    fetch.mockClear();
  });

  describe('fetchTemplates', () => {
    test('성공적인 템플릿 조회', async () => {
      const mockTemplates = [
        { id: 1, title: 'Template 1' },
        { id: 2, title: 'Template 2' }
      ];

      fetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({ data: mockTemplates })
      });

      const result = await fetchTemplates();

      expect(fetch).toHaveBeenCalledWith(
        expect.stringContaining('/api/templates'),
        expect.objectContaining({
          method: 'GET',
          headers: expect.objectContaining({
            'Content-Type': 'application/json'
          })
        })
      );
      expect(result).toEqual(mockTemplates);
    });

    test('네트워크 오류 처리', async () => {
      fetch.mockRejectedValueOnce(new Error('Network error'));

      await expect(fetchTemplates()).rejects.toThrow('Network error');
    });

    test('HTTP 오류 응답 처리', async () => {
      fetch.mockResolvedValueOnce({
        ok: false,
        status: 404,
        statusText: 'Not Found'
      });

      await expect(fetchTemplates()).rejects.toThrow('HTTP error! status: 404');
    });
  });

  describe('createTemplate', () => {
    test('새 템플릿 생성', async () => {
      const newTemplate = { title: 'New Template', content: 'Content' };
      const createdTemplate = { id: 3, ...newTemplate };

      fetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({ data: createdTemplate })
      });

      const result = await createTemplate(newTemplate);

      expect(fetch).toHaveBeenCalledWith(
        expect.stringContaining('/api/templates'),
        expect.objectContaining({
          method: 'POST',
          headers: expect.objectContaining({
            'Content-Type': 'application/json'
          }),
          body: JSON.stringify(newTemplate)
        })
      );
      expect(result).toEqual(createdTemplate);
    });
  });
});
```

#### JSON 파서 유틸리티 테스트
```jsx
// utils/jsonParser.test.js
import { parseJSON, validateTemplateFormat } from './jsonParser';

describe('JSON Parser Utils', () => {
  describe('parseJSON', () => {
    test('유효한 JSON 파싱', () => {
      const jsonString = '{"name": "test", "value": 123}';
      const result = parseJSON(jsonString);

      expect(result).toEqual({ name: 'test', value: 123 });
    });

    test('잘못된 JSON 처리', () => {
      const invalidJson = '{"name": "test", "value":}';

      expect(() => parseJSON(invalidJson)).toThrow('JSON 파싱 오류');
    });

    test('빈 문자열 처리', () => {
      expect(parseJSON('')).toBeNull();
      expect(parseJSON('   ')).toBeNull();
    });

    test('null/undefined 처리', () => {
      expect(parseJSON(null)).toBeNull();
      expect(parseJSON(undefined)).toBeNull();
    });
  });

  describe('validateTemplateFormat', () => {
    test('유효한 템플릿 형식', () => {
      const validTemplate = {
        title: 'Test Template',
        content: 'Hello {{name}}!',
        variables: [{ name: 'name', placeholder: '{{name}}' }]
      };

      expect(validateTemplateFormat(validTemplate)).toBe(true);
    });

    test('필수 필드 누락', () => {
      const invalidTemplate = {
        content: 'Hello world!'
        // title 누락
      };

      expect(() => validateTemplateFormat(invalidTemplate))
        .toThrow('필수 필드가 누락되었습니다: title');
    });

    test('변수와 플레이스홀더 불일치', () => {
      const invalidTemplate = {
        title: 'Test',
        content: 'Hello {{name}}!',
        variables: [{ name: 'age', placeholder: '{{age}}' }]
      };

      expect(() => validateTemplateFormat(invalidTemplate))
        .toThrow('변수와 플레이스홀더가 일치하지 않습니다');
    });
  });
});
```

## 🔗 통합 테스트 (Integration Testing)

### 1. API 통합 테스트 (MSW 사용)

#### MSW 설정
```jsx
// tests/mocks/handlers.js
import { rest } from 'msw';

export const handlers = [
  // 템플릿 목록 조회
  rest.get('/api/templates', (req, res, ctx) => {
    return res(
      ctx.json({
        data: [
          { id: 1, title: 'Template 1', status: 'approved' },
          { id: 2, title: 'Template 2', status: 'pending' }
        ]
      })
    );
  }),

  // 템플릿 생성
  rest.post('/api/templates', (req, res, ctx) => {
    const { title, content } = req.body;

    return res(
      ctx.json({
        data: {
          id: Date.now(),
          title,
          content,
          status: 'pending',
          createdAt: new Date().toISOString()
        }
      })
    );
  }),

  // 로그인
  rest.post('/api/auth/login', (req, res, ctx) => {
    const { email, password } = req.body;

    if (email === 'test@example.com' && password === 'password123') {
      return res(
        ctx.json({
          user: { id: 1, email, name: '테스트 사용자' },
          token: 'mock-jwt-token'
        })
      );
    }

    return res(
      ctx.status(401),
      ctx.json({ message: '인증에 실패했습니다.' })
    );
  }),

  // 에러 시뮬레이션
  rest.get('/api/templates/error', (req, res, ctx) => {
    return res(
      ctx.status(500),
      ctx.json({ message: '서버 내부 오류' })
    );
  })
];
```

```jsx
// tests/mocks/server.js
import { setupServer } from 'msw/node';
import { handlers } from './handlers';

export const server = setupServer(...handlers);
```

#### 테스트 설정
```jsx
// tests/setup.js
import { server } from './mocks/server';
import '@testing-library/jest-dom';

// 모든 테스트 시작 전 MSW 서버 시작
beforeAll(() => server.listen());

// 각 테스트 후 핸들러 리셋
afterEach(() => server.resetHandlers());

// 모든 테스트 완료 후 서버 종료
afterAll(() => server.close());
```

### 2. 사용자 플로우 통합 테스트

#### 로그인 플로우 테스트
```jsx
// tests/integration/LoginFlow.test.jsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import App from '../App';

const renderApp = () => {
  return render(
    <BrowserRouter>
      <App />
    </BrowserRouter>
  );
};

describe('로그인 플로우 통합 테스트', () => {
  test('성공적인 로그인 후 대시보드 이동', async () => {
    renderApp();

    // 로그인 페이지로 이동
    fireEvent.click(screen.getByText('로그인'));

    // 로그인 폼 작성
    fireEvent.change(screen.getByLabelText('이메일'), {
      target: { value: 'test@example.com' }
    });
    fireEvent.change(screen.getByLabelText('비밀번호'), {
      target: { value: 'password123' }
    });

    // 로그인 버튼 클릭
    fireEvent.click(screen.getByRole('button', { name: '로그인' }));

    // 대시보드 페이지로 리다이렉트 확인
    await waitFor(() => {
      expect(screen.getByText('대시보드')).toBeInTheDocument();
    });

    // 사용자 정보 표시 확인
    expect(screen.getByText('테스트 사용자님 환영합니다')).toBeInTheDocument();
  });

  test('잘못된 로그인 정보로 실패', async () => {
    renderApp();

    fireEvent.click(screen.getByText('로그인'));

    fireEvent.change(screen.getByLabelText('이메일'), {
      target: { value: 'wrong@example.com' }
    });
    fireEvent.change(screen.getByLabelText('비밀번호'), {
      target: { value: 'wrongpassword' }
    });

    fireEvent.click(screen.getByRole('button', { name: '로그인' }));

    // 에러 메시지 표시 확인
    await waitFor(() => {
      expect(screen.getByText('인증에 실패했습니다.')).toBeInTheDocument();
    });

    // 로그인 페이지에 계속 머물러 있는지 확인
    expect(screen.getByRole('button', { name: '로그인' })).toBeInTheDocument();
  });
});
```

#### 템플릿 생성 플로우 테스트
```jsx
// tests/integration/TemplateCreationFlow.test.jsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import GeneratorPageV2 from '../pages/GeneratorPageV2';

describe('템플릿 생성 플로우 통합 테스트', () => {
  test('AI를 통한 템플릿 생성 전체 플로우', async () => {
    render(
      <BrowserRouter>
        <GeneratorPageV2 />
      </BrowserRouter>
    );

    // 초기 화면 확인
    expect(screen.getByText('템플릿 생성')).toBeInTheDocument();
    expect(screen.getByPlaceholderText('어떤 템플릿을 만들까요?')).toBeInTheDocument();

    // 사용자 메시지 입력
    const input = screen.getByPlaceholderText('어떤 템플릿을 만들까요?');
    fireEvent.change(input, {
      target: { value: '카페 오픈 이벤트 알림톡을 만들어주세요' }
    });

    // 전송 버튼 클릭
    fireEvent.click(screen.getByRole('button', { name: '전송' }));

    // 사용자 메시지 표시 확인
    expect(screen.getByText('카페 오픈 이벤트 알림톡을 만들어주세요')).toBeInTheDocument();

    // 로딩 메시지 표시 확인
    expect(screen.getByText('템플릿을 생성하고 있습니다...')).toBeInTheDocument();

    // AI 응답 대기 (모킹된 응답)
    await waitFor(() => {
      expect(screen.getByText(/카페 오픈 이벤트/)).toBeInTheDocument();
    }, { timeout: 5000 });

    // 생성된 템플릿 확인
    expect(screen.getByText(/축하합니다!/)).toBeInTheDocument();
    expect(screen.getByText(/카페명/)).toBeInTheDocument();

    // 템플릿 저장 기능 테스트
    fireEvent.click(screen.getByText('템플릿 저장'));

    await waitFor(() => {
      expect(screen.getByText('템플릿이 저장되었습니다')).toBeInTheDocument();
    });
  });

  test('네트워크 오류 시 에러 처리', async () => {
    // 네트워크 오류 시뮬레이션
    server.use(
      rest.post('/api/generate', (req, res, ctx) => {
        return res.networkError('Failed to connect');
      })
    );

    render(
      <BrowserRouter>
        <GeneratorPageV2 />
      </BrowserRouter>
    );

    const input = screen.getByPlaceholderText('어떤 템플릿을 만들까요?');
    fireEvent.change(input, {
      target: { value: '테스트 메시지' }
    });

    fireEvent.click(screen.getByRole('button', { name: '전송' }));

    // 에러 메시지 표시 확인
    await waitFor(() => {
      expect(screen.getByText(/오류가 발생했습니다/)).toBeInTheDocument();
    });

    // 재시도 버튼 표시 확인
    expect(screen.getByText('다시 시도')).toBeInTheDocument();
  });
});
```

## 🌐 E2E 테스트 (End-to-End Testing)

### 1. Playwright 설정

#### Playwright 설정 파일
```javascript
// playwright.config.js
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',

  use: {
    baseURL: 'http://localhost:5173',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure'
  },

  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'Mobile Safari',
      use: { ...devices['iPhone 12'] },
    }
  ],

  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:5173',
    reuseExistingServer: !process.env.CI,
  },
});
```

### 2. 핵심 사용자 시나리오 E2E 테스트

#### 사용자 가입 및 로그인 시나리오
```javascript
// tests/e2e/auth.spec.js
import { test, expect } from '@playwright/test';

test.describe('사용자 인증', () => {
  test('새 사용자 가입 및 로그인', async ({ page }) => {
    // 랜딩 페이지 방문
    await page.goto('/');

    // 회원가입 페이지로 이동
    await page.click('text=회원가입');
    await expect(page).toHaveURL('/signup');

    // 회원가입 폼 작성
    await page.fill('[data-testid="email-input"]', 'newuser@example.com');
    await page.fill('[data-testid="password-input"]', 'password123!');
    await page.fill('[data-testid="confirm-password-input"]', 'password123!');
    await page.fill('[data-testid="name-input"]', '테스트 사용자');

    // 약관 동의 체크
    await page.check('[data-testid="terms-checkbox"]');

    // 회원가입 버튼 클릭
    await page.click('[data-testid="signup-button"]');

    // 성공 메시지 확인
    await expect(page.locator('text=회원가입이 완료되었습니다')).toBeVisible();

    // 로그인 페이지로 자동 이동
    await expect(page).toHaveURL('/login');

    // 로그인 수행
    await page.fill('[data-testid="email-input"]', 'newuser@example.com');
    await page.fill('[data-testid="password-input"]', 'password123!');
    await page.click('[data-testid="login-button"]');

    // 대시보드로 리다이렉트 확인
    await expect(page).toHaveURL('/dashboard');
    await expect(page.locator('text=테스트 사용자님 환영합니다')).toBeVisible();
  });

  test('잘못된 로그인 정보로 실패', async ({ page }) => {
    await page.goto('/login');

    await page.fill('[data-testid="email-input"]', 'wrong@example.com');
    await page.fill('[data-testid="password-input"]', 'wrongpassword');
    await page.click('[data-testid="login-button"]');

    // 에러 메시지 표시 확인
    await expect(page.locator('text=이메일 또는 비밀번호가 잘못되었습니다')).toBeVisible();

    // 로그인 페이지에 머물러 있는지 확인
    await expect(page).toHaveURL('/login');
  });
});
```

#### 템플릿 생성 및 관리 시나리오
```javascript
// tests/e2e/template-management.spec.js
import { test, expect } from '@playwright/test';

test.describe('템플릿 관리', () => {
  test.beforeEach(async ({ page }) => {
    // 테스트용 사용자로 로그인
    await page.goto('/login');
    await page.fill('[data-testid="email-input"]', 'test@example.com');
    await page.fill('[data-testid="password-input"]', 'password123');
    await page.click('[data-testid="login-button"]');
    await expect(page).toHaveURL('/dashboard');
  });

  test('AI를 통한 템플릿 생성 전체 플로우', async ({ page }) => {
    // 템플릿 생성 페이지로 이동
    await page.click('text=템플릿 생성');
    await expect(page).toHaveURL('/create');

    // 템플릿 요청 입력
    const requestText = '신제품 출시 알림톡을 만들어주세요. 제품명과 할인율을 변수로 사용하고 싶습니다.';
    await page.fill('[data-testid="chat-input"]', requestText);
    await page.click('[data-testid="send-button"]');

    // 사용자 메시지 확인
    await expect(page.locator(`text=${requestText}`)).toBeVisible();

    // 로딩 상태 확인
    await expect(page.locator('text=템플릿을 생성하고 있습니다')).toBeVisible();

    // AI 응답 대기 (최대 30초)
    await expect(page.locator('[data-testid="ai-response"]')).toBeVisible({ timeout: 30000 });

    // 생성된 템플릿 내용 확인
    await expect(page.locator('text=제품명')).toBeVisible();
    await expect(page.locator('text=할인율')).toBeVisible();

    // 템플릿 미리보기 확인
    const previewSection = page.locator('[data-testid="template-preview"]');
    await expect(previewSection).toBeVisible();

    // 변수 입력 테스트
    await page.fill('[data-testid="variable-제품명"]', '스마트폰');
    await page.fill('[data-testid="variable-할인율"]', '20%');

    // 실시간 미리보기 업데이트 확인
    await expect(page.locator('text=스마트폰')).toBeVisible();
    await expect(page.locator('text=20%')).toBeVisible();

    // 템플릿 저장
    await page.click('[data-testid="save-template-button"]');

    // 저장 성공 메시지 확인
    await expect(page.locator('text=템플릿이 저장되었습니다')).toBeVisible();

    // 템플릿 목록으로 자동 이동 확인
    await expect(page).toHaveURL('/templates');

    // 저장된 템플릿이 목록에 표시되는지 확인
    await expect(page.locator('text=신제품 출시')).toBeVisible();
  });

  test('템플릿 수정 및 삭제', async ({ page }) => {
    // 템플릿 목록 페이지로 이동
    await page.goto('/templates');

    // 첫 번째 템플릿 선택
    await page.click('[data-testid="template-item"]:first-child');

    // 템플릿 상세 페이지 확인
    await expect(page.locator('[data-testid="template-details"]')).toBeVisible();

    // 수정 버튼 클릭
    await page.click('[data-testid="edit-template-button"]');

    // 템플릿 제목 수정
    await page.fill('[data-testid="template-title"]', '수정된 템플릿 제목');

    // 템플릿 내용 수정
    await page.fill('[data-testid="template-content"]', '수정된 템플릿 내용입니다.');

    // 저장 버튼 클릭
    await page.click('[data-testid="save-changes-button"]');

    // 저장 성공 메시지 확인
    await expect(page.locator('text=템플릿이 수정되었습니다')).toBeVisible();

    // 수정된 내용 확인
    await expect(page.locator('text=수정된 템플릿 제목')).toBeVisible();

    // 삭제 테스트
    await page.click('[data-testid="delete-template-button"]');

    // 삭제 확인 모달
    await expect(page.locator('text=정말로 삭제하시겠습니까?')).toBeVisible();
    await page.click('[data-testid="confirm-delete-button"]');

    // 삭제 성공 메시지 확인
    await expect(page.locator('text=템플릿이 삭제되었습니다')).toBeVisible();

    // 템플릿 목록에서 제거되었는지 확인
    await expect(page.locator('text=수정된 템플릿 제목')).not.toBeVisible();
  });
});
```

#### 반응형 디자인 및 접근성 테스트
```javascript
// tests/e2e/responsive-accessibility.spec.js
import { test, expect } from '@playwright/test';

test.describe('반응형 디자인 및 접근성', () => {
  test('모바일 화면에서의 네비게이션', async ({ page }) => {
    // 모바일 뷰포트로 설정
    await page.setViewportSize({ width: 375, height: 667 });

    await page.goto('/dashboard');

    // 모바일 메뉴 버튼 확인
    const menuButton = page.locator('[data-testid="mobile-menu-button"]');
    await expect(menuButton).toBeVisible();

    // 메뉴 버튼 클릭
    await menuButton.click();

    // 모바일 메뉴 표시 확인
    const mobileMenu = page.locator('[data-testid="mobile-menu"]');
    await expect(mobileMenu).toBeVisible();

    // 메뉴 항목들 확인
    await expect(page.locator('text=대시보드')).toBeVisible();
    await expect(page.locator('text=템플릿 생성')).toBeVisible();
    await expect(page.locator('text=템플릿 목록')).toBeVisible();
  });

  test('키보드 네비게이션 테스트', async ({ page }) => {
    await page.goto('/dashboard');

    // Tab 키로 포커스 이동
    await page.keyboard.press('Tab');

    // 첫 번째 포커서블 요소에 포커스 확인
    const focusedElement = page.locator(':focus');
    await expect(focusedElement).toBeVisible();

    // Enter 키로 활성화
    await page.keyboard.press('Enter');

    // 적절한 액션이 실행되었는지 확인
    // (구체적인 확인 내용은 포커스된 요소에 따라 다름)
  });

  test('스크린 리더 지원 (ARIA 속성)', async ({ page }) => {
    await page.goto('/dashboard');

    // 주요 랜드마크 확인
    await expect(page.locator('main[role="main"]')).toBeVisible();
    await expect(page.locator('nav[role="navigation"]')).toBeVisible();

    // 버튼의 aria-label 확인
    const menuButton = page.locator('[aria-label="메인 메뉴 열기"]');
    await expect(menuButton).toBeVisible();

    // 로딩 상태의 aria-live 확인
    await page.goto('/create');
    await page.fill('[data-testid="chat-input"]', '테스트 메시지');
    await page.click('[data-testid="send-button"]');

    const loadingMessage = page.locator('[aria-live="polite"]');
    await expect(loadingMessage).toBeVisible();
  });

  test('다크 모드 토글 (미래 기능)', async ({ page }) => {
    await page.goto('/dashboard');

    // 다크 모드 토글 버튼 (향후 구현 예정)
    const darkModeToggle = page.locator('[data-testid="dark-mode-toggle"]');

    if (await darkModeToggle.isVisible()) {
      await darkModeToggle.click();

      // 다크 모드 적용 확인
      await expect(page.locator('body')).toHaveClass(/dark/);
    }
  });
});
```

## 📊 테스트 커버리지 및 품질 메트릭

### 1. 커버리지 설정

#### Jest 커버리지 설정
```json
// package.json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:ci": "jest --coverage --watchAll=false"
  },
  "jest": {
    "collectCoverageFrom": [
      "src/**/*.{js,jsx}",
      "!src/index.js",
      "!src/reportWebVitals.js",
      "!src/**/*.stories.js",
      "!src/**/*.test.js"
    ],
    "coverageThreshold": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": 80
      }
    },
    "coverageReporters": ["text", "lcov", "html"]
  }
}
```

### 2. 품질 게이트 설정

#### GitHub Actions CI/CD 설정
```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run ESLint
      run: npm run lint

    - name: Run unit tests
      run: npm run test:ci

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        token: ${{ secrets.CODECOV_TOKEN }}

    - name: Run E2E tests
      run: npx playwright test

    - name: Upload E2E test results
      uses: actions/upload-artifact@v3
      if: failure()
      with:
        name: playwright-report
        path: playwright-report/
```

### 3. 품질 메트릭 모니터링

#### SonarQube 설정 (선택사항)
```javascript
// sonar-project.properties
sonar.projectKey=jober-frontend
sonar.organization=team3
sonar.sources=src
sonar.tests=src
sonar.test.inclusions=**/*.test.js,**/*.test.jsx
sonar.javascript.lcov.reportPaths=coverage/lcov.info
sonar.exclusions=**/*.stories.js,**/node_modules/**
```

## 🛠️ 테스트 자동화 및 CI/CD 통합

### 1. 테스트 파이프라인

#### 로컬 개발 환경
```bash
# 개발 중 빠른 피드백
npm run test:watch

# 커밋 전 전체 테스트
npm run test:coverage
npm run lint
npm run e2e:headed
```

#### 빌드 파이프라인
```bash
# CI 환경에서 실행되는 순서
1. npm ci                    # 의존성 설치
2. npm run lint             # 정적 분석
3. npm run test:ci          # 단위/통합 테스트
4. npm run build            # 빌드
5. npx playwright test      # E2E 테스트
6. npm run lighthouse       # 성능 테스트 (선택)
```

### 2. 테스트 데이터 관리

#### 테스트 픽스처
```javascript
// tests/fixtures/users.js
export const testUsers = {
  admin: {
    id: 1,
    email: 'admin@example.com',
    name: '관리자',
    role: 'admin',
    plan: 'max'
  },
  user: {
    id: 2,
    email: 'user@example.com',
    name: '일반 사용자',
    role: 'user',
    plan: 'free'
  },
  proUser: {
    id: 3,
    email: 'pro@example.com',
    name: 'Pro 사용자',
    role: 'user',
    plan: 'pro'
  }
};

// tests/fixtures/templates.js
export const testTemplates = [
  {
    id: 1,
    title: '이벤트 알림톡',
    content: '🎉 {{이벤트명}} 이벤트가 시작되었습니다!\n\n📅 기간: {{시작일}} ~ {{종료일}}\n💰 혜택: {{할인율}}% 할인',
    variables: [
      { name: '이벤트명', placeholder: '{{이벤트명}}' },
      { name: '시작일', placeholder: '{{시작일}}' },
      { name: '종료일', placeholder: '{{종료일}}' },
      { name: '할인율', placeholder: '{{할인율}}' }
    ],
    status: 'approved',
    createdAt: '2024-01-01T00:00:00Z'
  },
  // 더 많은 테스트 템플릿...
];
```

#### 테스트 유틸리티
```javascript
// tests/utils/test-utils.jsx
import React from 'react';
import { render } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import { AuthProvider } from '../src/contexts/AuthContext';

// 공통 프로바이더들을 포함한 렌더링 헬퍼
export const renderWithProviders = (
  ui,
  {
    initialEntries = ['/'],
    user = null,
    ...renderOptions
  } = {}
) => {
  const Wrapper = ({ children }) => (
    <BrowserRouter>
      <AuthProvider initialUser={user}>
        {children}
      </AuthProvider>
    </BrowserRouter>
  );

  return render(ui, { wrapper: Wrapper, ...renderOptions });
};

// 인증된 사용자로 렌더링
export const renderAsUser = (ui, user = testUsers.user) => {
  return renderWithProviders(ui, { user });
};

// 관리자로 렌더링
export const renderAsAdmin = (ui) => {
  return renderWithProviders(ui, { user: testUsers.admin });
};

// 재사용 가능한 어써션 헬퍼들
export const expectLoadingToDisappear = async (container) => {
  await waitFor(() => {
    expect(container.querySelector('[data-testid="loading"]')).not.toBeInTheDocument();
  });
};

export const expectErrorMessage = (container, message) => {
  expect(container.querySelector('[role="alert"]')).toHaveTextContent(message);
};
```

## 🔧 성능 테스트

### 1. Lighthouse CI 설정

#### Lighthouse 설정
```javascript
// lighthouserc.js
module.exports = {
  ci: {
    collect: {
      url: [
        'http://localhost:5173/',
        'http://localhost:5173/dashboard',
        'http://localhost:5173/create',
        'http://localhost:5173/templates'
      ],
      startServerCommand: 'npm run preview',
      startServerReadyPattern: 'Local:',
      startServerTimeout: 30000
    },
    assert: {
      assertions: {
        'categories:performance': ['warn', { minScore: 0.8 }],
        'categories:accessibility': ['error', { minScore: 0.9 }],
        'categories:best-practices': ['warn', { minScore: 0.9 }],
        'categories:seo': ['warn', { minScore: 0.8 }]
      }
    },
    upload: {
      target: 'lhci',
      serverBaseUrl: process.env.LHCI_SERVER_BASE_URL,
      token: process.env.LHCI_TOKEN
    }
  }
};
```

### 2. 번들 분석

#### Webpack Bundle Analyzer
```json
// package.json
{
  "scripts": {
    "analyze": "npm run build && npx vite-bundle-analyzer dist"
  }
}
```

## 📈 테스트 리포팅 및 모니터링

### 1. 테스트 결과 리포팅

#### HTML 리포트 생성
```javascript
// jest.config.js
module.exports = {
  reporters: [
    'default',
    ['jest-html-reporters', {
      publicPath: './coverage/html-report',
      filename: 'report.html',
      expand: true,
      hideIcon: false
    }]
  ]
};
```

### 2. 실시간 모니터링

#### 테스트 메트릭 수집
```javascript
// tests/utils/metrics.js
export const recordTestMetrics = (testName, duration, status) => {
  // 테스트 실행 시간과 결과 기록
  const metrics = {
    testName,
    duration,
    status,
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV
  };

  // 메트릭 수집 서비스로 전송 (예: DataDog, New Relic)
  if (process.env.METRICS_ENDPOINT) {
    fetch(process.env.METRICS_ENDPOINT, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(metrics)
    }).catch(console.error);
  }
};
```

## 🏁 결론 및 모범 사례

### 주요 원칙

1. **테스트 피라미드 준수**: 80% 단위, 15% 통합, 5% E2E
2. **빠른 피드백**: 개발자가 즉시 결과를 확인할 수 있는 환경
3. **신뢰할 수 있는 테스트**: 플레이키하지 않고 일관된 결과
4. **의미 있는 커버리지**: 단순한 퍼센티지가 아닌 핵심 로직 커버
5. **유지보수 가능한 테스트**: 코드 변경 시 쉽게 업데이트 가능

### 향후 개선 계획

#### 단기 (1-2개월)
- [ ] 현재 컴포넌트들의 단위 테스트 100% 달성
- [ ] MSW를 활용한 API 통합 테스트 구축
- [ ] 기본적인 E2E 테스트 시나리오 구현
- [ ] CI/CD 파이프라인에 테스트 통합

#### 중기 (3-6개월)
- [ ] 시각적 회귀 테스트 도입
- [ ] 성능 테스트 자동화
- [ ] 접근성 테스트 강화
- [ ] 크로스 브라우저 테스트 확대

#### 장기 (6개월+)
- [ ] AI 기반 테스트 케이스 생성
- [ ] 사용자 행동 기반 테스트 시나리오 개발
- [ ] 실시간 품질 모니터링 대시보드
- [ ] 테스트 자동화 고도화

이 테스팅 전략을 통해 JOBER 프로젝트는 높은 품질과 안정성을 유지하며 지속적인 개선이 가능한 기반을 구축할 수 있습니다.

---

> 📅 **문서 버전**: v1.0
> 📅 **최종 수정일**: 2024-12-29
> 👥 **작성자**: Team 3 Frontend Development Team