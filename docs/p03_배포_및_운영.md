# p03_배포_및_운영

## 🚀 배포 전략 및 인프라 운영 가이드

**AI 알림톡 생성기**의 프로덕션 환경 배포, 모니터링, 그리고 운영을 위한 종합 가이드입니다. 20년간의 프론트엔드 운영 경험을 바탕으로 안정적이고 확장 가능한 배포 전략을 제시합니다.

---

## 📋 배포 환경 개요

### 현재 배포 인프라

| 환경 | 플랫폼 | 도메인 | 목적 |
|------|--------|--------|------|
| **Production** | Vercel | https://www.telosform.shop | 실제 사용자 서비스 |
| **Staging** | Vercel | https://staging.telosform.shop | 배포 전 검증 |
| **Development** | Local | http://localhost:5173 | 개발 및 테스트 |

### 배포 아키텍처 다이어그램

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────────┐
│   Developer     │    │    GitHub        │    │      Vercel         │
│   (Local Dev)   │───▶│   Repository     │───▶│   Auto Deploy       │
└─────────────────┘    └──────────────────┘    └─────────────────────┘
                                │                         │
                                │                         ▼
                         ┌──────▼──────┐         ┌──────────────────┐
                         │   GitHub    │         │    Production    │
                         │   Actions   │         │   Environment    │
                         │   (CI/CD)   │         │ telosform.shop   │
                         └─────────────┘         └──────────────────┘
```

---

## 🔧 Vercel 배포 설정 상세

### 프로젝트 설정 파일

#### vercel.json 완전 설정
```json
{
  "version": 2,
  "name": "ai-notification-generator",
  "alias": ["www.telosform.shop", "telosform.shop"],

  "builds": [
    {
      "src": "package.json",
      "use": "@vercel/static-build",
      "config": {
        "distDir": "dist",
        "zeroConfig": true
      }
    }
  ],

  "rewrites": [
    {
      "source": "/api/:path*",
      "destination": "http://54.116.0.21:8080/api/:path*"
    },
    {
      "source": "/((?!api/).*)",
      "destination": "/index.html"
    }
  ],

  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        {
          "key": "X-Content-Type-Options",
          "value": "nosniff"
        },
        {
          "key": "X-Frame-Options",
          "value": "DENY"
        },
        {
          "key": "X-XSS-Protection",
          "value": "1; mode=block"
        },
        {
          "key": "Referrer-Policy",
          "value": "strict-origin-when-cross-origin"
        },
        {
          "key": "Permissions-Policy",
          "value": "camera=(), microphone=(), geolocation=()"
        }
      ]
    },
    {
      "source": "/static/(.*)",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    }
  ],

  "redirects": [
    {
      "source": "/home",
      "destination": "/",
      "permanent": true
    }
  ],

  "env": {
    "NODE_ENV": "production"
  },

  "functions": {
    "app/api/*.js": {
      "maxDuration": 30
    }
  }
}
```

#### 환경변수 관리 전략
```bash
# Production Environment Variables (Vercel Dashboard)
VITE_API_URL=https://api.telosform.shop
VITE_APP_ENV=production
VITE_ENABLE_ANALYTICS=true
VITE_SENTRY_DSN=https://...
VITE_GA_TRACKING_ID=GA_MEASUREMENT_ID

# Staging Environment Variables
VITE_API_URL=https://staging-api.telosform.shop
VITE_APP_ENV=staging
VITE_ENABLE_ANALYTICS=false
VITE_DEBUG_MODE=true

# Development Environment Variables (.env.development)
VITE_API_URL=http://54.116.0.21:8080/api
VITE_APP_ENV=development
VITE_DEBUG_MODE=true
VITE_ENABLE_ANALYTICS=false
```

### Vercel CLI를 통한 고급 배포

#### 프로덕션 배포 스크립트
```bash
#!/bin/bash
# scripts/deploy-production.sh

echo "🚀 프로덕션 배포 시작..."

# 1. 의존성 검사
echo "📦 의존성 확인 중..."
npm ci

# 2. 타입 검사
echo "🔍 TypeScript 타입 검사..."
npm run type-check

# 3. 린트 검사
echo "🧹 ESLint 검사..."
npm run lint

# 4. 테스트 실행
echo "🧪 테스트 실행..."
npm run test -- --watchAll=false --coverage

# 5. 빌드 테스트
echo "🏗️ 프로덕션 빌드 테스트..."
npm run build

# 6. 번들 사이즈 분석
echo "📊 번들 사이즈 분석..."
npm run analyze

# 7. Vercel 배포
echo "🌐 Vercel 프로덕션 배포..."
vercel --prod --confirm

echo "✅ 배포 완료! https://www.telosform.shop"
```

#### 스테이징 배포 자동화
```bash
#!/bin/bash
# scripts/deploy-staging.sh

echo "🧪 스테이징 배포 시작..."

# 환경변수 설정
export VERCEL_ENV=preview

# 스테이징 배포
vercel --scope team-name --env VITE_APP_ENV=staging

echo "✅ 스테이징 배포 완료!"
```

---

## 🔄 CI/CD 파이프라인

### GitHub Actions 워크플로우

#### 메인 워크플로우 (.github/workflows/deploy.yml)
```yaml
name: Deploy to Vercel

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
  VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

jobs:
  quality-check:
    runs-on: ubuntu-latest

    steps:
      - name: 체크아웃
        uses: actions/checkout@v4

      - name: Node.js 설정
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: 의존성 설치
        run: npm ci

      - name: 타입 검사
        run: npm run type-check

      - name: 린트 검사
        run: npm run lint

      - name: 테스트 실행
        run: npm run test -- --watchAll=false --coverage

      - name: 빌드 테스트
        run: npm run build

      - name: 번들 사이즈 체크
        uses: andresz1/size-limit-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}

  deploy-staging:
    if: github.ref == 'refs/heads/develop'
    needs: quality-check
    runs-on: ubuntu-latest

    steps:
      - name: 체크아웃
        uses: actions/checkout@v4

      - name: Vercel CLI 설치
        run: npm install --global vercel@latest

      - name: Vercel 환경정보 가져오기
        run: vercel pull --yes --environment=preview --token=${{ secrets.VERCEL_TOKEN }}

      - name: Vercel 빌드
        run: vercel build --token=${{ secrets.VERCEL_TOKEN }}

      - name: 스테이징 배포
        run: vercel deploy --prebuilt --token=${{ secrets.VERCEL_TOKEN }}

  deploy-production:
    if: github.ref == 'refs/heads/main'
    needs: quality-check
    runs-on: ubuntu-latest

    steps:
      - name: 체크아웃
        uses: actions/checkout@v4

      - name: Vercel CLI 설치
        run: npm install --global vercel@latest

      - name: Vercel 환경정보 가져오기
        run: vercel pull --yes --environment=production --token=${{ secrets.VERCEL_TOKEN }}

      - name: Vercel 빌드
        run: vercel build --prod --token=${{ secrets.VERCEL_TOKEN }}

      - name: 프로덕션 배포
        run: vercel deploy --prebuilt --prod --token=${{ secrets.VERCEL_TOKEN }}

      - name: 배포 알림
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```

#### 보안 검사 워크플로우 (.github/workflows/security.yml)
```yaml
name: Security Scan

on:
  schedule:
    - cron: '0 2 * * 1' # 매주 월요일 오전 2시
  workflow_dispatch:

jobs:
  security-audit:
    runs-on: ubuntu-latest

    steps:
      - name: 체크아웃
        uses: actions/checkout@v4

      - name: Node.js 설정
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: 보안 감사
        run: npm audit --audit-level=high

      - name: Snyk 보안 테스트
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high

      - name: OWASP ZAP 베이스라인 스캔
        uses: zaproxy/action-baseline@v0.7.0
        with:
          target: 'https://www.telosform.shop'
```

---

## 📊 모니터링 및 관찰성

### 성능 모니터링 설정

#### Google Analytics 4 통합
```javascript
// src/utils/analytics.js
import { gtag } from 'ga-gtag';

class Analytics {
  constructor() {
    this.isEnabled = import.meta.env.VITE_ENABLE_ANALYTICS === 'true';
    this.trackingId = import.meta.env.VITE_GA_TRACKING_ID;
  }

  init() {
    if (!this.isEnabled || !this.trackingId) return;

    // GA4 초기화
    gtag('config', this.trackingId, {
      page_title: document.title,
      page_location: window.location.href,
    });
  }

  trackPageView(path) {
    if (!this.isEnabled) return;

    gtag('config', this.trackingId, {
      page_path: path,
      page_title: document.title,
    });
  }

  trackEvent(eventName, parameters = {}) {
    if (!this.isEnabled) return;

    gtag('event', eventName, {
      event_category: 'User Interaction',
      event_label: parameters.label,
      value: parameters.value,
      ...parameters,
    });
  }

  // 비즈니스 메트릭 추적
  trackTemplateGeneration(templateType, userId) {
    this.trackEvent('template_generated', {
      event_category: 'Template',
      template_type: templateType,
      user_id: userId,
    });
  }

  trackChatHistoryAccess(historyCount) {
    this.trackEvent('chat_history_accessed', {
      event_category: 'Chat',
      history_count: historyCount,
    });
  }
}

export const analytics = new Analytics();
```

#### Sentry 에러 추적 설정
```javascript
// src/utils/errorTracking.js
import * as Sentry from "@sentry/react";
import { BrowserTracing } from "@sentry/tracing";

export function initSentry() {
  Sentry.init({
    dsn: import.meta.env.VITE_SENTRY_DSN,
    environment: import.meta.env.VITE_APP_ENV,

    integrations: [
      new BrowserTracing({
        // 라우팅 성능 추적
        routingInstrumentation: Sentry.reactRouterV6Instrumentation(
          React.useEffect,
          useLocation,
          useNavigationType,
          createRoutesFromChildren,
          matchRoutes
        ),
      }),
    ],

    // 성능 모니터링 샘플링 비율
    tracesSampleRate: import.meta.env.VITE_APP_ENV === 'production' ? 0.1 : 1.0,

    // 세션 재생 (프로덕션에서만)
    replaysSessionSampleRate: import.meta.env.VITE_APP_ENV === 'production' ? 0.1 : 0,
    replaysOnErrorSampleRate: 1.0,

    beforeSend(event, hint) {
      // 개발 환경에서는 콘솔에 출력
      if (import.meta.env.VITE_APP_ENV === 'development') {
        console.error('Sentry Event:', event, hint);
      }

      // PII 정보 제거
      if (event.user) {
        delete event.user.email;
        delete event.user.ip_address;
      }

      return event;
    },
  });
}

// 사용자 컨텍스트 설정
export function setSentryUser(user) {
  Sentry.setUser({
    id: user.id,
    username: user.nickname,
    segment: user.plan_type,
  });
}

// 커스텀 에러 리포팅
export function reportError(error, context = {}) {
  Sentry.withScope((scope) => {
    scope.setContext("error_context", context);
    scope.setLevel("error");
    Sentry.captureException(error);
  });
}
```

### 실시간 모니터링 대시보드

#### Core Web Vitals 추적
```javascript
// src/utils/webVitals.js
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

function sendToAnalytics(metric) {
  // Google Analytics로 전송
  gtag('event', metric.name, {
    event_category: 'Web Vitals',
    event_label: metric.id,
    value: Math.round(metric.value),
    non_interaction: true,
  });

  // Sentry로 성능 데이터 전송
  Sentry.addBreadcrumb({
    category: 'performance',
    message: `${metric.name}: ${metric.value}`,
    level: 'info',
  });

  // 임계값 초과 시 알림
  const thresholds = {
    CLS: 0.1,
    FID: 100,
    FCP: 1800,
    LCP: 2500,
    TTFB: 600,
  };

  if (metric.value > thresholds[metric.name]) {
    reportError(new Error(`${metric.name} threshold exceeded`), {
      metric_name: metric.name,
      metric_value: metric.value,
      threshold: thresholds[metric.name],
    });
  }
}

// Core Web Vitals 측정 시작
export function startWebVitalsMonitoring() {
  getCLS(sendToAnalytics);
  getFID(sendToAnalytics);
  getFCP(sendToAnalytics);
  getLCP(sendToAnalytics);
  getTTFB(sendToAnalytics);
}
```

---

## 🔐 보안 및 컴플라이언스

### HTTPS 및 SSL 인증서

#### Vercel 자동 SSL 설정
```javascript
// 자동 HTTPS 리다이렉트 및 HSTS 설정
// vercel.json에 이미 포함된 보안 헤더들

const securityHeaders = [
  {
    key: 'Strict-Transport-Security',
    value: 'max-age=63072000; includeSubDomains; preload'
  },
  {
    key: 'Content-Security-Policy',
    value: [
      "default-src 'self'",
      "script-src 'self' 'unsafe-inline' 'unsafe-eval' https://www.googletagmanager.com",
      "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com",
      "font-src 'self' https://fonts.gstatic.com",
      "img-src 'self' data: https:",
      "connect-src 'self' https://api.telosform.shop https://www.google-analytics.com",
      "frame-ancestors 'none'"
    ].join('; ')
  }
];
```

### 데이터 보호 및 개인정보

#### 개인정보 처리 방침 구현
```javascript
// src/utils/privacy.js
class PrivacyManager {
  constructor() {
    this.consentKey = 'user_consent';
    this.consentExpiry = 365 * 24 * 60 * 60 * 1000; // 1년
  }

  hasConsent() {
    const consent = localStorage.getItem(this.consentKey);
    if (!consent) return false;

    const { timestamp, granted } = JSON.parse(consent);
    const isExpired = Date.now() - timestamp > this.consentExpiry;

    return granted && !isExpired;
  }

  grantConsent() {
    const consent = {
      timestamp: Date.now(),
      granted: true,
      version: '1.0'
    };

    localStorage.setItem(this.consentKey, JSON.stringify(consent));

    // 동의 후 분석 도구 활성화
    analytics.init();
  }

  revokeConsent() {
    localStorage.removeItem(this.consentKey);

    // 분석 데이터 삭제
    this.clearAnalyticsData();
  }

  clearAnalyticsData() {
    // GA4 데이터 삭제 요청
    gtag('consent', 'update', {
      analytics_storage: 'denied',
      ad_storage: 'denied'
    });
  }
}

export const privacyManager = new PrivacyManager();
```

---

## 🚨 장애 대응 및 복구

### 장애 대응 절차

#### 1. 장애 감지 및 알림 시스템
```javascript
// src/utils/healthCheck.js
class HealthMonitor {
  constructor() {
    this.endpoints = [
      { name: 'Frontend', url: 'https://www.telosform.shop/health' },
      { name: 'Backend API', url: 'https://api.telosform.shop/health' },
    ];

    this.alertThreshold = 3; // 3번 연속 실패 시 알림
    this.checkInterval = 60000; // 1분마다 체크
  }

  async checkHealth() {
    const results = await Promise.allSettled(
      this.endpoints.map(endpoint => this.pingEndpoint(endpoint))
    );

    results.forEach((result, index) => {
      const endpoint = this.endpoints[index];

      if (result.status === 'rejected') {
        this.handleEndpointFailure(endpoint, result.reason);
      } else {
        this.handleEndpointSuccess(endpoint);
      }
    });
  }

  async pingEndpoint(endpoint) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 5000);

    try {
      const response = await fetch(endpoint.url, {
        signal: controller.signal,
        method: 'HEAD'
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      return { endpoint: endpoint.name, status: 'healthy' };
    } catch (error) {
      clearTimeout(timeoutId);
      throw new Error(`${endpoint.name} 응답 없음: ${error.message}`);
    }
  }

  handleEndpointFailure(endpoint, error) {
    console.error(`🚨 ${endpoint.name} 장애 감지:`, error);

    // Slack 알림 전송
    this.sendSlackAlert({
      endpoint: endpoint.name,
      error: error.message,
      timestamp: new Date().toISOString()
    });

    // Sentry 에러 리포팅
    reportError(new Error(`Health check failed: ${endpoint.name}`), {
      endpoint_name: endpoint.name,
      error_message: error.message
    });
  }

  async sendSlackAlert(alertData) {
    if (!import.meta.env.VITE_SLACK_WEBHOOK_URL) return;

    const payload = {
      text: `🚨 서비스 장애 알림`,
      attachments: [{
        color: 'danger',
        fields: [
          { title: 'Endpoint', value: alertData.endpoint, short: true },
          { title: 'Error', value: alertData.error, short: true },
          { title: 'Time', value: alertData.timestamp, short: true }
        ]
      }]
    };

    try {
      await fetch(import.meta.env.VITE_SLACK_WEBHOOK_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
    } catch (error) {
      console.error('Slack 알림 전송 실패:', error);
    }
  }

  start() {
    this.checkHealth(); // 즉시 실행
    this.intervalId = setInterval(() => this.checkHealth(), this.checkInterval);
  }

  stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
    }
  }
}

export const healthMonitor = new HealthMonitor();
```

#### 2. 자동 롤백 시스템
```bash
#!/bin/bash
# scripts/emergency-rollback.sh

echo "🚨 긴급 롤백 시작..."

# 현재 배포 정보 백업
vercel ls --token=$VERCEL_TOKEN > rollback-info.txt

# 이전 안정 버전으로 롤백
PREVIOUS_DEPLOYMENT=$(vercel ls --token=$VERCEL_TOKEN | grep "Ready" | head -2 | tail -1 | awk '{print $1}')

if [ -n "$PREVIOUS_DEPLOYMENT" ]; then
    echo "이전 배포로 롤백: $PREVIOUS_DEPLOYMENT"
    vercel promote $PREVIOUS_DEPLOYMENT --token=$VERCEL_TOKEN

    # Slack 알림
    curl -X POST -H 'Content-type: application/json' \
        --data "{\"text\":\"✅ 긴급 롤백 완료: $PREVIOUS_DEPLOYMENT\"}" \
        $SLACK_WEBHOOK_URL
else
    echo "❌ 롤백할 이전 배포를 찾을 수 없습니다"
    exit 1
fi

echo "✅ 롤백 완료"
```

### 데이터 백업 및 복구

#### 채팅 기록 백업 시스템
```javascript
// src/utils/backupManager.js
class ChatBackupManager {
  constructor() {
    this.backupKey = 'chat_backup';
    this.maxBackups = 5;
  }

  async createBackup() {
    try {
      const chatHistory = chatHistoryStorage.load();
      const backup = {
        timestamp: Date.now(),
        data: chatHistory,
        version: '1.0',
        checksum: this.calculateChecksum(chatHistory)
      };

      const existingBackups = this.getExistingBackups();
      const updatedBackups = [backup, ...existingBackups]
        .slice(0, this.maxBackups);

      localStorage.setItem(this.backupKey, JSON.stringify(updatedBackups));

      console.log('📦 채팅 데이터 백업 완료:', backup.timestamp);
      return backup;
    } catch (error) {
      console.error('백업 생성 실패:', error);
      throw error;
    }
  }

  async restoreFromBackup(timestamp) {
    try {
      const backups = this.getExistingBackups();
      const targetBackup = backups.find(b => b.timestamp === timestamp);

      if (!targetBackup) {
        throw new Error('해당 시점의 백업을 찾을 수 없습니다');
      }

      // 체크섬 검증
      const currentChecksum = this.calculateChecksum(targetBackup.data);
      if (currentChecksum !== targetBackup.checksum) {
        throw new Error('백업 데이터가 손상되었습니다');
      }

      // 데이터 복원
      chatHistoryStorage.save(targetBackup.data);

      console.log('🔄 채팅 데이터 복원 완료:', timestamp);
      return targetBackup.data;
    } catch (error) {
      console.error('데이터 복원 실패:', error);
      throw error;
    }
  }

  getExistingBackups() {
    try {
      const backups = localStorage.getItem(this.backupKey);
      return backups ? JSON.parse(backups) : [];
    } catch (error) {
      console.error('백업 목록 로드 실패:', error);
      return [];
    }
  }

  calculateChecksum(data) {
    // 간단한 체크섬 계산 (실제로는 crypto API 사용 권장)
    return btoa(JSON.stringify(data)).length.toString(36);
  }

  // 자동 백업 스케줄링
  startAutoBackup() {
    // 10분마다 자동 백업
    this.backupInterval = setInterval(() => {
      this.createBackup().catch(console.error);
    }, 10 * 60 * 1000);
  }

  stopAutoBackup() {
    if (this.backupInterval) {
      clearInterval(this.backupInterval);
    }
  }
}

export const backupManager = new ChatBackupManager();
```

---

## 📈 성능 최적화 및 스케일링

### CDN 최적화 전략

#### Vercel Edge Network 활용
```javascript
// next.config.js (향후 Next.js 마이그레이션 시)
module.exports = {
  // Edge Runtime 활용
  experimental: {
    runtime: 'edge',
  },

  // 이미지 최적화
  images: {
    domains: ['assets.telosform.shop'],
    formats: ['image/webp', 'image/avif'],
    minimumCacheTTL: 31536000, // 1년
  },

  // 캐시 최적화
  async headers() {
    return [
      {
        source: '/static/(.*)',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable',
          },
        ],
      },
    ];
  },
};
```

#### 지역별 성능 최적화
```javascript
// src/utils/geoOptimization.js
class GeoOptimization {
  constructor() {
    this.cdnEndpoints = {
      'KR': 'https://kr-cdn.telosform.shop',
      'US': 'https://us-cdn.telosform.shop',
      'EU': 'https://eu-cdn.telosform.shop',
      'default': 'https://global-cdn.telosform.shop'
    };
  }

  async detectUserRegion() {
    try {
      // Vercel의 지역 감지 헤더 활용
      const response = await fetch('/api/geo');
      const { country } = await response.json();

      return this.getRegionFromCountry(country);
    } catch (error) {
      console.warn('지역 감지 실패, 기본값 사용:', error);
      return 'default';
    }
  }

  getRegionFromCountry(country) {
    const regionMapping = {
      'KR': 'KR',
      'JP': 'KR', // 일본도 한국 CDN 사용
      'US': 'US',
      'CA': 'US',
      'GB': 'EU',
      'DE': 'EU',
      'FR': 'EU',
    };

    return regionMapping[country] || 'default';
  }

  async getOptimalEndpoint() {
    const region = await this.detectUserRegion();
    return this.cdnEndpoints[region];
  }
}

export const geoOptimization = new GeoOptimization();
```

### 자동 스케일링 모니터링

#### 사용량 기반 알림 시스템
```javascript
// src/utils/usageMonitor.js
class UsageMonitor {
  constructor() {
    this.thresholds = {
      dailyUsers: 1000,
      monthlyRequests: 100000,
      errorRate: 0.05, // 5%
    };
  }

  async checkUsageMetrics() {
    try {
      const metrics = await this.fetchVercelMetrics();

      if (metrics.dailyUsers > this.thresholds.dailyUsers) {
        this.sendScalingAlert('Daily users threshold exceeded', {
          current: metrics.dailyUsers,
          threshold: this.thresholds.dailyUsers
        });
      }

      if (metrics.errorRate > this.thresholds.errorRate) {
        this.sendScalingAlert('Error rate threshold exceeded', {
          current: (metrics.errorRate * 100).toFixed(2) + '%',
          threshold: (this.thresholds.errorRate * 100) + '%'
        });
      }
    } catch (error) {
      console.error('사용량 모니터링 실패:', error);
    }
  }

  async fetchVercelMetrics() {
    // Vercel API에서 메트릭 조회
    const response = await fetch(`https://api.vercel.com/v1/projects/${PROJECT_ID}/analytics`, {
      headers: {
        'Authorization': `Bearer ${VERCEL_TOKEN}`
      }
    });

    return await response.json();
  }

  sendScalingAlert(message, data) {
    // Slack 알림
    const payload = {
      text: `⚠️ 스케일링 알림: ${message}`,
      attachments: [{
        color: 'warning',
        fields: Object.entries(data).map(([key, value]) => ({
          title: key,
          value: value,
          short: true
        }))
      }]
    };

    fetch(import.meta.env.VITE_SLACK_WEBHOOK_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
  }
}

export const usageMonitor = new UsageMonitor();
```

---

## 🛠️ 운영 도구 및 자동화

### 로그 수집 및 분석

#### 구조화된 로깅 시스템
```javascript
// src/utils/logger.js
class Logger {
  constructor() {
    this.logLevel = import.meta.env.VITE_LOG_LEVEL || 'info';
    this.environment = import.meta.env.VITE_APP_ENV;
  }

  log(level, message, context = {}) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      context,
      environment: this.environment,
      userAgent: navigator.userAgent,
      url: window.location.href,
      sessionId: this.getSessionId(),
    };

    // 콘솔 출력
    console[level](message, context);

    // 프로덕션 환경에서는 외부 로그 서비스로 전송
    if (this.environment === 'production') {
      this.sendToLogService(logEntry);
    }
  }

  info(message, context) {
    this.log('info', message, context);
  }

  warn(message, context) {
    this.log('warn', message, context);
  }

  error(message, context) {
    this.log('error', message, context);

    // 에러는 Sentry로도 전송
    reportError(new Error(message), context);
  }

  debug(message, context) {
    if (this.logLevel === 'debug') {
      this.log('debug', message, context);
    }
  }

  getSessionId() {
    let sessionId = sessionStorage.getItem('session_id');
    if (!sessionId) {
      sessionId = 'sess_' + Math.random().toString(36).substr(2, 9);
      sessionStorage.setItem('session_id', sessionId);
    }
    return sessionId;
  }

  async sendToLogService(logEntry) {
    try {
      await fetch('/api/logs', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(logEntry)
      });
    } catch (error) {
      console.error('로그 전송 실패:', error);
    }
  }
}

export const logger = new Logger();
```

### 배포 품질 게이트

#### 자동화된 품질 검사
```bash
#!/bin/bash
# scripts/quality-gate.sh

echo "🚦 배포 품질 게이트 실행..."

# 1. 성능 테스트
echo "⚡ 성능 테스트..."
npm run build
npm run lighthouse -- --output-path=./reports/lighthouse.json

# 성능 점수 확인
PERFORMANCE_SCORE=$(cat ./reports/lighthouse.json | jq '.categories.performance.score * 100')
if (( $(echo "$PERFORMANCE_SCORE < 90" | bc -l) )); then
    echo "❌ 성능 점수 부족: $PERFORMANCE_SCORE (최소 90 필요)"
    exit 1
fi

# 2. 접근성 테스트
echo "♿ 접근성 테스트..."
ACCESSIBILITY_SCORE=$(cat ./reports/lighthouse.json | jq '.categories.accessibility.score * 100')
if (( $(echo "$ACCESSIBILITY_SCORE < 95" | bc -l) )); then
    echo "❌ 접근성 점수 부족: $ACCESSIBILITY_SCORE (최소 95 필요)"
    exit 1
fi

# 3. 보안 검사
echo "🔒 보안 검사..."
npm audit --audit-level=high
if [ $? -ne 0 ]; then
    echo "❌ 보안 취약점 발견"
    exit 1
fi

# 4. 번들 사이즈 체크
echo "📦 번들 사이즈 체크..."
BUNDLE_SIZE=$(du -k dist/assets/*.js | awk '{total += $1} END {print total}')
MAX_SIZE=500 # 500KB

if [ "$BUNDLE_SIZE" -gt "$MAX_SIZE" ]; then
    echo "❌ 번들 사이즈 초과: ${BUNDLE_SIZE}KB (최대 ${MAX_SIZE}KB)"
    exit 1
fi

echo "✅ 모든 품질 게이트 통과!"
```

---

## 📋 운영 체크리스트

### 일일 운영 체크리스트

#### 매일 확인 항목
```markdown
## 🌅 일일 운영 체크리스트

### 시스템 상태 확인
- [ ] 웹사이트 접속 확인 (https://www.telosform.shop)
- [ ] API 응답 시간 확인 (< 2초)
- [ ] CDN 상태 확인
- [ ] SSL 인증서 만료일 확인

### 성능 지표 확인
- [ ] Core Web Vitals 점수 확인
- [ ] 에러율 확인 (< 1%)
- [ ] 페이지 로딩 시간 확인
- [ ] 사용자 세션 수 확인

### 보안 상태 확인
- [ ] 보안 스캔 결과 확인
- [ ] 접근 로그 이상 여부 확인
- [ ] 의존성 취약점 확인
- [ ] 백업 상태 확인

### 비즈니스 메트릭 확인
- [ ] 일일 활성 사용자 수
- [ ] 템플릿 생성 수
- [ ] 에러 발생 패턴 분석
- [ ] 사용자 피드백 확인
```

### 주간 운영 체크리스트

```markdown
## 📊 주간 운영 체크리스트

### 성능 분석
- [ ] 주간 성능 트렌드 분석
- [ ] 사용자 경험 지표 검토
- [ ] 리소스 사용량 분석
- [ ] 성능 최적화 기회 식별

### 보안 및 컴플라이언스
- [ ] 보안 패치 적용 검토
- [ ] 접근 로그 분석
- [ ] 백업 무결성 검증
- [ ] 개인정보 처리 현황 검토

### 코드 품질 관리
- [ ] 코드 리뷰 백로그 정리
- [ ] 기술 부채 평가
- [ ] 테스트 커버리지 확인
- [ ] 의존성 업데이트 검토

### 사용자 경험 개선
- [ ] 사용자 피드백 분석
- [ ] A/B 테스트 결과 검토
- [ ] UX 개선 아이디어 수집
- [ ] 기능 사용률 분석
```

---

## 🎯 결론: 안정적이고 확장 가능한 운영 체계

이 배포 및 운영 문서는 **AI 알림톡 생성기**의 장기적인 안정성과 성장을 보장하기 위한 종합적인 가이드입니다. 20년간의 프론트엔드 운영 경험에서 얻은 교훈을 바탕으로, 다음과 같은 핵심 원칙을 적용했습니다:

### 🏆 운영 철학의 핵심 가치

1. **신뢰성 우선**: 99.9% 가용성을 목표로 하는 안정적인 서비스
2. **성능 최적화**: 사용자 경험을 최우선으로 하는 지속적인 성능 개선
3. **보안 강화**: 다층 보안 체계를 통한 데이터 보호
4. **자동화 추진**: 반복 작업의 자동화를 통한 운영 효율성 극대화
5. **관찰성 확보**: 포괄적인 모니터링을 통한 proactive 문제 해결

### 📊 운영 성과 지표

현재 구축된 운영 체계를 통해 달성 가능한 목표:

- **가용성**: 99.9% (월 43분 이하 다운타임)
- **성능**: Core Web Vitals 모든 지표 "Good" 등급 유지
- **보안**: 무장애 보안 사고 달성
- **배포**: 일 평균 5회 이상의 안전한 배포
- **복구**: 평균 5분 이내 장애 복구

### 🚀 지속적인 개선을 위한 로드맵

1. **단기 (1-3개월)**:
   - 실시간 모니터링 대시보드 구축
   - 자동화된 성능 테스트 도입
   - 장애 대응 절차 자동화

2. **중기 (3-6개월)**:
   - 멀티 리전 배포 구축
   - 고급 A/B 테스트 인프라
   - 예측적 확장 시스템

3. **장기 (6개월+)**:
   - AI 기반 이상 탐지 시스템
   - 완전 자동화된 운영 환경
   - 글로벌 서비스 인프라

이러한 운영 체계는 현재의 서비스 안정성을 보장하는 동시에, **미래의 성장과 확장에 유연하게 대응할 수 있는 견고한 기반**을 제공합니다. 지속적인 모니터링과 개선을 통해 세계 수준의 웹 서비스 운영 환경을 구축해 나가겠습니다.