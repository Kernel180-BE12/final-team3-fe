# 모니터링 및 알람 설정 가이드

## 📋 목차
1. [모니터링 개요](#모니터링-개요)
2. [성능 모니터링](#성능-모니터링)
3. [에러 추적 및 로깅](#에러-추적-및-로깅)
4. [사용자 행동 분석](#사용자-행동-분석)
5. [인프라 모니터링](#인프라-모니터링)
6. [알람 시스템 구성](#알람-시스템-구성)
7. [대시보드 구성](#대시보드-구성)
8. [장애 대응 절차](#장애-대응-절차)

## 📊 모니터링 개요

### 모니터링 목표
1. **사용자 경험 최적화**: 성능 병목 지점 식별 및 개선
2. **서비스 안정성 확보**: 장애 사전 감지 및 빠른 대응
3. **비즈니스 메트릭 추적**: 핵심 지표 모니터링 및 분석
4. **보안 위협 대응**: 비정상 패턴 감지 및 보안 사고 예방

### 모니터링 스택
```yaml
Frontend:
  Performance: Web Vitals, Lighthouse CI
  Error Tracking: Sentry
  Analytics: Google Analytics 4, Mixpanel
  RUM: Chrome DevTools, WebPageTest

Backend:
  APM: New Relic, DataDog
  Logging: ELK Stack (Elasticsearch, Logstash, Kibana)
  Infrastructure: CloudWatch, Prometheus + Grafana

Alerting:
  Notification: Slack, PagerDuty, Email
  Escalation: Phone calls, SMS
```

## ⚡ 성능 모니터링

### Core Web Vitals 모니터링
```javascript
// Web Vitals 메트릭 수집
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

class PerformanceMonitor {
  constructor() {
    this.metrics = {};
    this.thresholds = {
      LCP: 2500,    // Largest Contentful Paint
      FID: 100,     // First Input Delay
      CLS: 0.1,     // Cumulative Layout Shift
      FCP: 1800,    // First Contentful Paint
      TTFB: 600     // Time to First Byte
    };
  }

  init() {
    // Core Web Vitals 수집
    getCLS(this.sendMetric.bind(this));
    getFID(this.sendMetric.bind(this));
    getFCP(this.sendMetric.bind(this));
    getLCP(this.sendMetric.bind(this));
    getTTFB(this.sendMetric.bind(this));

    // 커스텀 메트릭 추가
    this.measureCustomMetrics();
  }

  sendMetric(metric) {
    const { name, value, rating } = metric;

    // 임계값 초과 시 알람
    if (this.thresholds[name] && value > this.thresholds[name]) {
      this.sendAlert(`${name} 임계값 초과`, {
        metric: name,
        value,
        threshold: this.thresholds[name],
        rating,
        url: window.location.href,
        userAgent: navigator.userAgent
      });
    }

    // 메트릭 저장 및 전송
    this.metrics[name] = { value, rating, timestamp: Date.now() };
    this.sendToAnalytics(metric);
  }

  measureCustomMetrics() {
    // 템플릿 생성 완료 시간
    const measureTemplateGeneration = () => {
      const startTime = performance.mark('template-generation-start');

      return () => {
        const endTime = performance.mark('template-generation-end');
        const measure = performance.measure(
          'template-generation',
          'template-generation-start',
          'template-generation-end'
        );

        this.sendMetric({
          name: 'template-generation-time',
          value: measure.duration,
          rating: measure.duration > 5000 ? 'poor' : 'good'
        });
      };
    };

    window.measureTemplateGeneration = measureTemplateGeneration;

    // API 응답 시간 측정
    this.interceptFetch();
  }

  interceptFetch() {
    const originalFetch = window.fetch;

    window.fetch = async (...args) => {
      const startTime = performance.now();
      const url = args[0];

      try {
        const response = await originalFetch(...args);
        const endTime = performance.now();
        const duration = endTime - startTime;

        this.sendMetric({
          name: 'api-response-time',
          value: duration,
          rating: duration > 3000 ? 'poor' : duration > 1000 ? 'needs-improvement' : 'good',
          url: url,
          status: response.status
        });

        return response;
      } catch (error) {
        const endTime = performance.now();
        const duration = endTime - startTime;

        this.sendMetric({
          name: 'api-error',
          value: duration,
          rating: 'poor',
          url: url,
          error: error.message
        });

        throw error;
      }
    };
  }

  sendAlert(message, details) {
    // Slack 알람 전송
    fetch('/api/alerts/slack', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        message,
        details,
        severity: 'warning',
        timestamp: new Date().toISOString()
      })
    });
  }

  sendToAnalytics(metric) {
    // Google Analytics 4로 전송
    if (typeof gtag !== 'undefined') {
      gtag('event', 'web_vitals', {
        event_category: 'Performance',
        event_label: metric.name,
        value: Math.round(metric.value),
        custom_map: {
          metric_rating: metric.rating
        }
      });
    }

    // 커스텀 분석 서버로 전송
    fetch('/api/metrics', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...metric,
        page: window.location.pathname,
        sessionId: this.getSessionId(),
        userId: this.getUserId(),
        timestamp: Date.now()
      })
    });
  }
}

// 모니터링 초기화
const performanceMonitor = new PerformanceMonitor();
performanceMonitor.init();
```

### 번들 크기 모니터링
```javascript
// 번들 크기 추적 (Webpack Bundle Analyzer 연동)
const BundleSizeMonitor = {
  // vite.config.js 설정
  setupBundleAnalysis() {
    return {
      plugins: [
        // 번들 크기 시각화
        visualizer({
          filename: 'dist/stats.html',
          open: false,
          gzipSize: true
        }),

        // 번들 크기 추적
        {
          name: 'bundle-size-tracker',
          generateBundle(options, bundle) {
            const bundleInfo = Object.entries(bundle).map(([fileName, chunk]) => ({
              fileName,
              size: chunk.code ? chunk.code.length : 0,
              type: chunk.type
            }));

            const totalSize = bundleInfo.reduce((acc, chunk) => acc + chunk.size, 0);

            // 크기 임계값 확인 (1MB)
            if (totalSize > 1024 * 1024) {
              console.warn(`⚠️ 번들 크기 경고: ${(totalSize / 1024 / 1024).toFixed(2)}MB`);

              // CI/CD에서 슬랙 알람
              if (process.env.CI) {
                this.sendBundleSizeAlert(totalSize, bundleInfo);
              }
            }

            // 번들 정보 저장
            this.saveBundleInfo(bundleInfo, totalSize);
          }
        }
      ]
    };
  },

  sendBundleSizeAlert(totalSize, bundleInfo) {
    const sizeInMB = (totalSize / 1024 / 1024).toFixed(2);
    const largestChunks = bundleInfo
      .sort((a, b) => b.size - a.size)
      .slice(0, 5)
      .map(chunk => `${chunk.fileName}: ${(chunk.size / 1024).toFixed(1)}KB`)
      .join('\n');

    const message = `
🚨 번들 크기 경고
총 크기: ${sizeInMB}MB (임계값: 1MB 초과)

주요 청크:
${largestChunks}

빌드 정보:
- 브랜치: ${process.env.CI_BRANCH}
- 커밋: ${process.env.CI_COMMIT}
    `;

    // Slack webhook으로 전송
    fetch(process.env.SLACK_WEBHOOK_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text: message })
    });
  }
};
```

## 🐛 에러 추적 및 로깅

### Sentry 에러 추적 설정
```javascript
// Sentry 초기화
import * as Sentry from '@sentry/react';
import { BrowserTracing } from '@sentry/tracing';

Sentry.init({
  dsn: process.env.REACT_APP_SENTRY_DSN,
  environment: process.env.NODE_ENV,

  // 성능 모니터링
  integrations: [
    new BrowserTracing({
      // 자동 계측할 라우트 설정
      tracePropagationTargets: ['localhost', /^https:\/\/api\.yourservice\.com/],
    }),
  ],

  // 성능 추적 샘플링 비율
  tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,

  // 에러 필터링
  beforeSend(event, hint) {
    // 개발 환경에서는 콘솔에도 출력
    if (process.env.NODE_ENV === 'development') {
      console.error('Sentry Error:', event, hint);
    }

    // 스팸성 에러 필터링
    if (event.exception) {
      const error = event.exception.values[0];
      if (error.value && error.value.includes('Script error')) {
        return null; // 브라우저 확장프로그램 에러 무시
      }
    }

    return event;
  },

  // 사용자 정보 설정
  initialScope: {
    tags: {
      component: 'frontend',
      version: process.env.REACT_APP_VERSION
    }
  }
});

// 에러 바운더리와 함께 사용
const SentryErrorBoundary = ({ children }) => {
  return (
    <Sentry.ErrorBoundary
      fallback={({ error, resetError }) => (
        <div className="error-fallback">
          <h2>문제가 발생했습니다</h2>
          <pre>{error.message}</pre>
          <button onClick={resetError}>다시 시도</button>
        </div>
      )}
      beforeCapture={(scope) => {
        scope.setTag('errorBoundary', true);
      }}
    >
      {children}
    </Sentry.ErrorBoundary>
  );
};
```

### 커스텀 로깅 시스템
```javascript
// 구조화된 로깅 시스템
class Logger {
  constructor() {
    this.logLevel = process.env.NODE_ENV === 'production' ? 'error' : 'debug';
    this.logQueue = [];
    this.maxQueueSize = 100;
    this.flushInterval = 30000; // 30초마다 전송

    this.startPeriodicFlush();
  }

  static LEVELS = {
    debug: 0,
    info: 1,
    warn: 2,
    error: 3
  };

  log(level, message, context = {}) {
    if (Logger.LEVELS[level] < Logger.LEVELS[this.logLevel]) {
      return;
    }

    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      context: {
        ...context,
        url: window.location.href,
        userAgent: navigator.userAgent,
        sessionId: this.getSessionId(),
        userId: this.getUserId()
      }
    };

    // 콘솔 출력
    console[level](`[${logEntry.timestamp}] ${message}`, context);

    // 큐에 추가
    this.logQueue.push(logEntry);

    // 큐 크기 관리
    if (this.logQueue.length > this.maxQueueSize) {
      this.logQueue.shift();
    }

    // 에러는 즉시 전송
    if (level === 'error') {
      this.flush();
    }
  }

  // 로그 레벨별 헬퍼 메서드
  debug(message, context) { this.log('debug', message, context); }
  info(message, context) { this.log('info', message, context); }
  warn(message, context) { this.log('warn', message, context); }
  error(message, context) { this.log('error', message, context); }

  // 비즈니스 이벤트 로깅
  logUserAction(action, details = {}) {
    this.info(`User Action: ${action}`, {
      category: 'user_action',
      action,
      ...details
    });
  }

  logPerformance(metric, value, details = {}) {
    this.info(`Performance: ${metric}`, {
      category: 'performance',
      metric,
      value,
      ...details
    });
  }

  logApiCall(method, url, duration, status, error = null) {
    const level = error ? 'error' : status >= 400 ? 'warn' : 'info';
    this.log(level, `API Call: ${method} ${url}`, {
      category: 'api',
      method,
      url,
      duration,
      status,
      error: error?.message
    });
  }

  // 로그 전송
  async flush() {
    if (this.logQueue.length === 0) return;

    const logs = [...this.logQueue];
    this.logQueue = [];

    try {
      await fetch('/api/logs', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ logs })
      });
    } catch (error) {
      console.error('로그 전송 실패:', error);
      // 실패한 로그는 다시 큐에 추가 (최대 한 번만)
      if (logs.length < this.maxQueueSize / 2) {
        this.logQueue.unshift(...logs);
      }
    }
  }

  startPeriodicFlush() {
    setInterval(() => {
      this.flush();
    }, this.flushInterval);

    // 페이지 언로드 시 마지막 전송
    window.addEventListener('beforeunload', () => {
      this.flush();
    });
  }

  getSessionId() {
    let sessionId = sessionStorage.getItem('sessionId');
    if (!sessionId) {
      sessionId = crypto.randomUUID();
      sessionStorage.setItem('sessionId', sessionId);
    }
    return sessionId;
  }

  getUserId() {
    // 인증된 사용자 ID 반환
    return JSON.parse(localStorage.getItem('user'))?.id || 'anonymous';
  }
}

// 전역 로거 인스턴스
const logger = new Logger();
window.logger = logger;

// React 에러 캐치
window.addEventListener('error', (event) => {
  logger.error('JavaScript Error', {
    message: event.message,
    filename: event.filename,
    line: event.lineno,
    column: event.colno,
    stack: event.error?.stack
  });
});

window.addEventListener('unhandledrejection', (event) => {
  logger.error('Unhandled Promise Rejection', {
    reason: event.reason,
    stack: event.reason?.stack
  });
});
```

## 👥 사용자 행동 분석

### Google Analytics 4 설정
```javascript
// GA4 이벤트 추적
class AnalyticsTracker {
  constructor() {
    this.userId = null;
    this.sessionId = this.getSessionId();
  }

  // 사용자 식별
  setUser(userId) {
    this.userId = userId;
    gtag('config', process.env.REACT_APP_GA_TRACKING_ID, {
      user_id: userId
    });
  }

  // 페이지 뷰
  trackPageView(path, title) {
    gtag('event', 'page_view', {
      page_title: title,
      page_location: window.location.href,
      page_path: path
    });
  }

  // 비즈니스 이벤트
  trackTemplateGeneration(templateId, category, success) {
    gtag('event', 'template_generation', {
      event_category: 'Templates',
      event_label: category,
      template_id: templateId,
      success: success,
      value: success ? 1 : 0
    });

    // 커스텀 메트릭으로도 전송
    logger.logUserAction('template_generation', {
      templateId,
      category,
      success
    });
  }

  trackTemplateApproval(templateId, status, rejectionReason = null) {
    gtag('event', 'template_approval', {
      event_category: 'Templates',
      event_label: status,
      template_id: templateId,
      rejection_reason: rejectionReason
    });
  }

  trackSubscription(plan, action) {
    gtag('event', 'subscription', {
      event_category: 'Revenue',
      event_label: plan,
      action: action, // subscribe, upgrade, downgrade, cancel
      value: this.getPlanValue(plan)
    });
  }

  trackError(errorType, errorMessage, component) {
    gtag('event', 'exception', {
      description: `${errorType}: ${errorMessage}`,
      fatal: false,
      component: component
    });
  }

  // 사용자 흐름 추적
  trackUserFlow(step, completed = false) {
    gtag('event', 'user_flow', {
      event_category: 'User Journey',
      event_label: step,
      completed: completed
    });
  }

  getPlanValue(plan) {
    const planValues = {
      'free': 0,
      'pro': 29000,
      'max': 99000
    };
    return planValues[plan] || 0;
  }

  getSessionId() {
    let sessionId = sessionStorage.getItem('analytics_session');
    if (!sessionId) {
      sessionId = Date.now().toString();
      sessionStorage.setItem('analytics_session', sessionId);
    }
    return sessionId;
  }
}

// 전역 분석 추적기
const analytics = new AnalyticsTracker();
window.analytics = analytics;
```

### 사용자 행동 히트맵 (Hotjar/FullStory)
```javascript
// 히트맵 및 세션 리플레이 설정
class UserBehaviorTracker {
  constructor() {
    this.hotjarId = process.env.REACT_APP_HOTJAR_ID;
    this.initHotjar();
  }

  initHotjar() {
    (function(h,o,t,j,a,r){
      h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
      h._hjSettings={hjid: this.hotjarId, hjsv:6};
      a=o.getElementsByTagName('head')[0];
      r=o.createElement('script');r.async=1;
      r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
      a.appendChild(r);
    })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
  }

  // 특정 페이지에서 녹화 시작
  startRecording(pageName) {
    if (window.hj) {
      hj('trigger', pageName);
    }
  }

  // 사용자 속성 설정
  setUserAttributes(attributes) {
    if (window.hj) {
      hj('identify', this.userId, attributes);
    }
  }

  // 커스텀 이벤트 추적
  trackEvent(eventName, properties = {}) {
    if (window.hj) {
      hj('event', eventName, properties);
    }
  }
}
```

## 🖥️ 인프라 모니터링

### CloudWatch 메트릭 (AWS 기준)
```javascript
// 클라이언트 사이드 메트릭 전송
class InfrastructureMonitor {
  constructor() {
    this.region = process.env.REACT_APP_AWS_REGION;
    this.namespace = 'JOBER/Frontend';
  }

  // 사용자 인터랙션 메트릭
  trackUserMetrics() {
    // 동시 접속자 수 추정
    this.sendMetric('ConcurrentUsers', 1, 'Count');

    // 세션 시작
    this.sendMetric('SessionStarted', 1, 'Count');

    // 페이지 로드 시간
    window.addEventListener('load', () => {
      const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;
      this.sendMetric('PageLoadTime', loadTime, 'Milliseconds');
    });
  }

  // 에러율 추적
  trackErrorRate() {
    let errorCount = 0;
    let totalRequests = 0;

    // API 요청 추적
    const originalFetch = window.fetch;
    window.fetch = async (...args) => {
      totalRequests++;

      try {
        const response = await originalFetch(...args);

        if (!response.ok) {
          errorCount++;
          this.sendMetric('APIErrorRate', (errorCount / totalRequests) * 100, 'Percent');
        }

        return response;
      } catch (error) {
        errorCount++;
        this.sendMetric('APIErrorRate', (errorCount / totalRequests) * 100, 'Percent');
        throw error;
      }
    };
  }

  // 메트릭 전송
  sendMetric(metricName, value, unit) {
    fetch('/api/metrics/cloudwatch', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        namespace: this.namespace,
        metricData: [{
          MetricName: metricName,
          Value: value,
          Unit: unit,
          Timestamp: new Date(),
          Dimensions: [
            { Name: 'Environment', Value: process.env.NODE_ENV },
            { Name: 'Page', Value: window.location.pathname }
          ]
        }]
      })
    });
  }
}
```

## 🚨 알람 시스템 구성

### 알람 정책 설정
```javascript
// 알람 매니저
class AlertManager {
  constructor() {
    this.alertChannels = {
      slack: process.env.REACT_APP_SLACK_WEBHOOK,
      email: '/api/alerts/email',
      sms: '/api/alerts/sms'
    };

    this.alertRules = [
      {
        name: 'High Error Rate',
        condition: (metrics) => metrics.errorRate > 5, // 5% 이상
        severity: 'critical',
        channels: ['slack', 'email', 'sms']
      },
      {
        name: 'Slow Page Load',
        condition: (metrics) => metrics.avgLoadTime > 3000, // 3초 이상
        severity: 'warning',
        channels: ['slack']
      },
      {
        name: 'High Memory Usage',
        condition: (metrics) => metrics.memoryUsage > 80, // 80% 이상
        severity: 'warning',
        channels: ['slack']
      },
      {
        name: 'API Timeout',
        condition: (metrics) => metrics.avgResponseTime > 10000, // 10초 이상
        severity: 'critical',
        channels: ['slack', 'email']
      }
    ];
  }

  checkAlerts(metrics) {
    this.alertRules.forEach(rule => {
      if (rule.condition(metrics)) {
        this.sendAlert(rule, metrics);
      }
    });
  }

  async sendAlert(rule, metrics) {
    const alertMessage = {
      title: `🚨 ${rule.name}`,
      severity: rule.severity,
      timestamp: new Date().toISOString(),
      metrics: metrics,
      runbook: this.getRunbookUrl(rule.name),
      environment: process.env.NODE_ENV
    };

    // 각 채널로 알람 발송
    rule.channels.forEach(channel => {
      this.sendToChannel(channel, alertMessage);
    });
  }

  async sendToChannel(channel, message) {
    try {
      switch (channel) {
        case 'slack':
          await this.sendSlackAlert(message);
          break;
        case 'email':
          await this.sendEmailAlert(message);
          break;
        case 'sms':
          await this.sendSMSAlert(message);
          break;
      }
    } catch (error) {
      console.error(`알람 발송 실패 (${channel}):`, error);
    }
  }

  async sendSlackAlert(message) {
    const slackPayload = {
      text: message.title,
      attachments: [{
        color: this.getSeverityColor(message.severity),
        fields: [
          { title: 'Severity', value: message.severity, short: true },
          { title: 'Environment', value: message.environment, short: true },
          { title: 'Time', value: message.timestamp, short: true },
          { title: 'Runbook', value: message.runbook, short: true }
        ],
        footer: 'JOBER Monitoring',
        ts: Math.floor(Date.now() / 1000)
      }]
    };

    await fetch(this.alertChannels.slack, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(slackPayload)
    });
  }

  getSeverityColor(severity) {
    const colors = {
      critical: '#ff0000',
      warning: '#ffaa00',
      info: '#00aa00'
    };
    return colors[severity] || '#cccccc';
  }

  getRunbookUrl(ruleName) {
    const runbooks = {
      'High Error Rate': 'https://wiki.company.com/runbooks/high-error-rate',
      'Slow Page Load': 'https://wiki.company.com/runbooks/performance',
      'High Memory Usage': 'https://wiki.company.com/runbooks/memory',
      'API Timeout': 'https://wiki.company.com/runbooks/api-timeout'
    };
    return runbooks[ruleName] || 'https://wiki.company.com/runbooks';
  }
}
```

### 알람 에스컬레이션 정책
```yaml
# 알람 에스컬레이션 설정
escalation_policies:
  critical:
    level_1:
      channels: ['slack']
      delay: 0  # 즉시
    level_2:
      channels: ['email', 'slack']
      delay: 5  # 5분 후
    level_3:
      channels: ['sms', 'phone']
      delay: 15  # 15분 후
    level_4:
      channels: ['manager_phone']
      delay: 30  # 30분 후

  warning:
    level_1:
      channels: ['slack']
      delay: 0
    level_2:
      channels: ['email']
      delay: 30  # 30분 후

  info:
    level_1:
      channels: ['slack']
      delay: 0
```

## 📈 대시보드 구성

### Grafana 대시보드 설정
```json
{
  "dashboard": {
    "title": "JOBER Frontend Monitoring",
    "panels": [
      {
        "title": "Core Web Vitals",
        "type": "graph",
        "targets": [
          {
            "expr": "web_vitals_lcp",
            "legendFormat": "LCP"
          },
          {
            "expr": "web_vitals_fid",
            "legendFormat": "FID"
          },
          {
            "expr": "web_vitals_cls",
            "legendFormat": "CLS"
          }
        ],
        "yAxes": [
          {
            "label": "Milliseconds",
            "min": 0
          }
        ],
        "alert": {
          "conditions": [
            {
              "query": "A",
              "reducer": {
                "type": "avg"
              },
              "evaluator": {
                "params": [2500],
                "type": "gt"
              }
            }
          ],
          "executionErrorState": "alerting",
          "frequency": "10s",
          "handler": 1,
          "name": "LCP Alert",
          "noDataState": "no_data"
        }
      },
      {
        "title": "Error Rate",
        "type": "singlestat",
        "targets": [
          {
            "expr": "rate(frontend_errors_total[5m]) * 100",
            "legendFormat": "Error Rate %"
          }
        ],
        "thresholds": "3,5",
        "colorBackground": true
      },
      {
        "title": "User Sessions",
        "type": "graph",
        "targets": [
          {
            "expr": "frontend_active_users",
            "legendFormat": "Active Users"
          }
        ]
      },
      {
        "title": "API Response Times",
        "type": "heatmap",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(api_request_duration_seconds_bucket[5m]))",
            "legendFormat": "95th percentile"
          }
        ]
      }
    ]
  }
}
```

### 실시간 상태 페이지
```jsx
// 실시간 모니터링 컴포넌트
const MonitoringDashboard = () => {
  const [metrics, setMetrics] = useState({});
  const [alerts, setAlerts] = useState([]);

  useEffect(() => {
    // WebSocket으로 실시간 메트릭 수신
    const ws = new WebSocket(process.env.REACT_APP_MONITORING_WS);

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);

      if (data.type === 'metrics') {
        setMetrics(prev => ({ ...prev, ...data.metrics }));
      } else if (data.type === 'alert') {
        setAlerts(prev => [data.alert, ...prev.slice(0, 9)]);
      }
    };

    return () => ws.close();
  }, []);

  return (
    <div className="monitoring-dashboard">
      <div className="metrics-grid">
        <MetricCard
          title="응답 시간"
          value={`${metrics.avgResponseTime || 0}ms`}
          status={metrics.avgResponseTime > 1000 ? 'warning' : 'good'}
        />
        <MetricCard
          title="에러율"
          value={`${(metrics.errorRate || 0).toFixed(2)}%`}
          status={metrics.errorRate > 1 ? 'error' : 'good'}
        />
        <MetricCard
          title="활성 사용자"
          value={metrics.activeUsers || 0}
          status="good"
        />
        <MetricCard
          title="페이지 로드"
          value={`${metrics.avgLoadTime || 0}ms`}
          status={metrics.avgLoadTime > 3000 ? 'warning' : 'good'}
        />
      </div>

      <div className="alerts-section">
        <h3>최근 알람</h3>
        {alerts.map((alert, index) => (
          <AlertItem key={index} alert={alert} />
        ))}
      </div>
    </div>
  );
};

const MetricCard = ({ title, value, status }) => {
  const statusColors = {
    good: 'text-green-600 bg-green-100',
    warning: 'text-yellow-600 bg-yellow-100',
    error: 'text-red-600 bg-red-100'
  };

  return (
    <div className={`p-4 rounded-lg ${statusColors[status]}`}>
      <h4 className="text-sm font-medium">{title}</h4>
      <p className="text-2xl font-bold">{value}</p>
    </div>
  );
};
```

## 🚨 장애 대응 절차

### 장애 대응 플레이북
```markdown
# 장애 대응 절차

## 1단계: 장애 감지 및 확인 (0-5분)
- [ ] 알람 수신 확인
- [ ] 장애 범위 파악 (전체/부분)
- [ ] 사용자 영향도 평가
- [ ] 장애 심각도 결정

## 2단계: 초기 대응 (5-15분)
- [ ] 장애 상황 슬랙 채널 공지
- [ ] 상태 페이지 업데이트
- [ ] 임시 우회 방안 검토
- [ ] 롤백 필요성 판단

## 3단계: 원인 분석 및 해결 (15분-2시간)
- [ ] 로그 분석 수행
- [ ] 메트릭 데이터 검토
- [ ] 최근 배포 내역 확인
- [ ] 해결 방안 수립 및 실행

## 4단계: 복구 확인 (해결 후 30분)
- [ ] 서비스 정상 작동 확인
- [ ] 메트릭 정상화 확인
- [ ] 사용자 피드백 모니터링
- [ ] 상태 페이지 정상화

## 5단계: 사후 처리 (24-48시간 내)
- [ ] 장애 보고서 작성
- [ ] 근본 원인 분석 (RCA)
- [ ] 재발 방지 대책 수립
- [ ] 프로세스 개선 사항 도출
```

### 자동 복구 스크립트
```javascript
// 자동 복구 메커니즘
class AutoRecovery {
  constructor() {
    this.recoveryStrategies = {
      'api_timeout': this.handleApiTimeout.bind(this),
      'memory_leak': this.handleMemoryLeak.bind(this),
      'high_error_rate': this.handleHighErrorRate.bind(this)
    };
  }

  async handleApiTimeout() {
    console.log('API 타임아웃 감지 - 재시도 로직 실행');

    // 1. 캐시된 데이터로 대체
    this.useCachedData();

    // 2. 사용자에게 알림
    this.showUserNotification('일시적으로 느릴 수 있습니다');

    // 3. 백그라운드에서 재시도
    await this.retryWithExponentialBackoff();
  }

  async handleMemoryLeak() {
    console.log('메모리 누수 감지 - 정리 작업 실행');

    // 1. 불필요한 이벤트 리스너 정리
    this.cleanupEventListeners();

    // 2. 캐시 정리
    this.clearCache();

    // 3. 가비지 컬렉션 강제 실행 (가능한 경우)
    if (window.gc) {
      window.gc();
    }
  }

  async handleHighErrorRate() {
    console.log('높은 에러율 감지 - 서킷 브레이커 활성화');

    // 1. 서킷 브레이커 패턴 적용
    this.enableCircuitBreaker();

    // 2. 오프라인 모드 활성화
    this.enableOfflineMode();

    // 3. 관리자에게 알림
    this.notifyAdministrators();
  }

  enableCircuitBreaker() {
    // API 호출 일시 중단
    window.circuitBreakerEnabled = true;

    setTimeout(() => {
      window.circuitBreakerEnabled = false;
      console.log('서킷 브레이커 해제');
    }, 60000); // 1분 후 재시도
  }
}
```

---

## 📚 모니터링 도구 비교

| 도구 | 용도 | 장점 | 단점 | 비용 |
|------|------|------|------|------|
| Sentry | 에러 추적 | 상세한 에러 정보 | 트래픽 기반 과금 | $$ |
| DataDog | 종합 모니터링 | 올인원 솔루션 | 높은 비용 | $$$ |
| New Relic | APM | 상세한 성능 분석 | 복잡한 설정 | $$$ |
| Google Analytics | 사용자 분석 | 무료, 강력한 분석 | 프라이버시 이슈 | Free |
| Hotjar | 사용자 행동 | 시각적 분석 | 제한적 세션 수 | $$ |

---

## 🎯 모니터링 성숙도 로드맵

### Level 1: 기본 모니터링
- [ ] 에러 추적 (Sentry)
- [ ] 기본 성능 메트릭 (Web Vitals)
- [ ] 사용자 분석 (GA4)
- [ ] 슬랙 알람

### Level 2: 고급 모니터링
- [ ] 사용자 세션 리플레이 (Hotjar)
- [ ] 인프라 메트릭 (CloudWatch)
- [ ] 커스텀 대시보드 (Grafana)
- [ ] 알람 에스컬레이션

### Level 3: 프로액티브 모니터링
- [ ] 예측적 알람
- [ ] 자동 복구 시스템
- [ ] A/B 테스트 모니터링
- [ ] 비즈니스 메트릭 연동

---

*마지막 업데이트: 2024-09*
*문서 담당: DevOps Team*