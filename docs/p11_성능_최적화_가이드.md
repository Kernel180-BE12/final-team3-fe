# 성능 최적화 가이드

## 📋 목차
1. [성능 측정 도구](#성능-측정-도구)
2. [번들 최적화](#번들-최적화)
3. [런타임 최적화](#런타임-최적화)
4. [네트워크 최적화](#네트워크-최적화)
5. [렌더링 최적화](#렌더링-최적화)
6. [메모리 최적화](#메모리-최적화)
7. [성능 모니터링](#성능-모니터링)
8. [최적화 체크리스트](#최적화-체크리스트)

## 🔍 성능 측정 도구

### 브라우저 개발자 도구
```javascript
// Performance API 활용
const startTime = performance.now();
// 측정할 코드
const endTime = performance.now();
console.log(`실행 시간: ${endTime - startTime}ms`);

// 메모리 사용량 측정
if (performance.memory) {
  console.log('Used:', performance.memory.usedJSHeapSize);
  console.log('Total:', performance.memory.totalJSHeapSize);
  console.log('Limit:', performance.memory.jsHeapSizeLimit);
}
```

### Lighthouse 성능 감사
```bash
# 프로덕션 빌드 성능 측정
npm run build
npm run preview

# Lighthouse CLI (옵션)
npm install -g lighthouse
lighthouse http://localhost:4173 --output html --output-path ./lighthouse-report.html
```

### React DevTools Profiler
```jsx
// 성능 프로파일링을 위한 컴포넌트 래핑
import { Profiler } from 'react';

function onRenderCallback(id, phase, actualDuration) {
  console.log('Component:', id, 'Phase:', phase, 'Duration:', actualDuration);
}

function App() {
  return (
    <Profiler id="App" onRender={onRenderCallback}>
      <YourComponent />
    </Profiler>
  );
}
```

### 번들 분석 도구
```bash
# 번들 크기 분석
npm install --save-dev rollup-plugin-visualizer

# vite.config.js에 추가
import { visualizer } from 'rollup-plugin-visualizer';

export default {
  plugins: [
    // ... 다른 플러그인들
    visualizer({
      filename: 'dist/stats.html',
      open: true,
      gzipSize: true
    })
  ]
}
```

## 📦 번들 최적화

### 코드 스플리팅 (Code Splitting)
```jsx
// 1. 라우트 기반 분할
import { lazy, Suspense } from 'react';

const GeneratorPage = lazy(() => import('./pages/GeneratorPage'));
const StatisticsPage = lazy(() => import('./pages/StatisticsPage'));

function App() {
  return (
    <Suspense fallback={<div>로딩 중...</div>}>
      <Routes>
        <Route path="/generator" element={<GeneratorPage />} />
        <Route path="/statistics" element={<StatisticsPage />} />
      </Routes>
    </Suspense>
  );
}

// 2. 컴포넌트 기반 분할
const HeavyChart = lazy(() => import('./components/HeavyChart'));

function Dashboard() {
  const [showChart, setShowChart] = useState(false);

  return (
    <div>
      <button onClick={() => setShowChart(true)}>
        차트 보기
      </button>
      {showChart && (
        <Suspense fallback={<div>차트 로딩 중...</div>}>
          <HeavyChart />
        </Suspense>
      )}
    </div>
  );
}
```

### Tree Shaking 최적화
```javascript
// 잘못된 예: 전체 라이브러리 import
import _ from 'lodash';

// 올바른 예: 필요한 함수만 import
import { debounce, throttle } from 'lodash';
// 또는
import debounce from 'lodash/debounce';

// Tailwind CSS 최적화
// tailwind.config.js
module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
    "./index.html"
  ],
  // 사용하지 않는 클래스 제거
  purge: {
    enabled: true,
    content: ['./src/**/*.{js,jsx}']
  }
}
```

### 의존성 최적화
```javascript
// vite.config.js - 사전 번들링 최적화
export default {
  optimizeDeps: {
    include: [
      'react',
      'react-dom',
      'react-router-dom',
      'zustand'
    ],
    exclude: ['@vite/client', '@vite/env']
  },
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'react-vendor': ['react', 'react-dom'],
          'router': ['react-router-dom'],
          'ui-vendor': ['@headlessui/react', '@heroicons/react']
        }
      }
    }
  }
}
```

## ⚡ 런타임 최적화

### React.memo와 useMemo 활용
```jsx
// 1. React.memo로 불필요한 리렌더링 방지
const TemplateCard = React.memo(({ template, onApprove }) => {
  return (
    <div className="p-4 border rounded">
      <h3>{template.title}</h3>
      <button onClick={onApprove}>승인</button>
    </div>
  );
});

// 2. useMemo로 비싼 계산 최적화
function StatisticsPage({ data }) {
  const expensiveChartData = useMemo(() => {
    return data.reduce((acc, item) => {
      // 복잡한 데이터 변환 로직
      return processChartData(acc, item);
    }, []);
  }, [data]);

  const filteredData = useMemo(() => {
    return data.filter(item => item.status === 'approved');
  }, [data]);

  return <Chart data={expensiveChartData} />;
}

// 3. useCallback으로 함수 메모이제이션
function TemplateList({ templates }) {
  const handleApprove = useCallback((templateId) => {
    // API 호출 로직
    approveTemplate(templateId);
  }, []);

  const handleDelete = useCallback((templateId) => {
    // API 호출 로직
    deleteTemplate(templateId);
  }, []);

  return (
    <div>
      {templates.map(template => (
        <TemplateCard
          key={template.id}
          template={template}
          onApprove={() => handleApprove(template.id)}
          onDelete={() => handleDelete(template.id)}
        />
      ))}
    </div>
  );
}
```

### 가상화 (Virtualization)
```jsx
// 대용량 리스트 가상화
import { FixedSizeList as List } from 'react-window';

function TemplateList({ templates }) {
  const Row = ({ index, style }) => (
    <div style={style}>
      <TemplateCard template={templates[index]} />
    </div>
  );

  return (
    <List
      height={600}
      itemCount={templates.length}
      itemSize={120}
      overscanCount={5}
    >
      {Row}
    </List>
  );
}
```

### 디바운싱과 스로틀링
```jsx
// 검색 입력 디바운싱
import { useMemo, useState, useEffect } from 'react';
import { debounce } from 'lodash';

function SearchInput({ onSearch }) {
  const [query, setQuery] = useState('');

  const debouncedSearch = useMemo(
    () => debounce(onSearch, 300),
    [onSearch]
  );

  useEffect(() => {
    if (query) {
      debouncedSearch(query);
    }
    return () => debouncedSearch.cancel();
  }, [query, debouncedSearch]);

  return (
    <input
      type="text"
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      placeholder="템플릿 검색..."
    />
  );
}

// 스크롤 이벤트 스로틀링
import { throttle } from 'lodash';

function useScrollPosition() {
  const [scrollY, setScrollY] = useState(0);

  useEffect(() => {
    const handleScroll = throttle(() => {
      setScrollY(window.scrollY);
    }, 100);

    window.addEventListener('scroll', handleScroll);
    return () => {
      window.removeEventListener('scroll', handleScroll);
      handleScroll.cancel();
    };
  }, []);

  return scrollY;
}
```

## 🌐 네트워크 최적화

### API 호출 최적화
```javascript
// 1. 요청 중복 제거
const requestCache = new Map();

async function fetchWithCache(url) {
  if (requestCache.has(url)) {
    return requestCache.get(url);
  }

  const promise = fetch(url).then(res => res.json());
  requestCache.set(url, promise);

  try {
    const result = await promise;
    return result;
  } catch (error) {
    requestCache.delete(url);
    throw error;
  }
}

// 2. 배치 요청
function useBatchRequests() {
  const [pendingRequests, setPendingRequests] = useState([]);

  const addRequest = useCallback((request) => {
    setPendingRequests(prev => [...prev, request]);
  }, []);

  useEffect(() => {
    if (pendingRequests.length === 0) return;

    const timer = setTimeout(() => {
      // 여러 요청을 하나로 배치
      const batchPayload = {
        requests: pendingRequests.map(req => ({
          method: req.method,
          url: req.url,
          data: req.data
        }))
      };

      fetch('/api/batch', {
        method: 'POST',
        body: JSON.stringify(batchPayload)
      });

      setPendingRequests([]);
    }, 50);

    return () => clearTimeout(timer);
  }, [pendingRequests]);

  return { addRequest };
}
```

### 이미지 최적화
```jsx
// 1. 지연 로딩 (Lazy Loading)
function LazyImage({ src, alt, className }) {
  const [isLoaded, setIsLoaded] = useState(false);
  const [isInView, setIsInView] = useState(false);
  const imgRef = useRef();

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsInView(true);
          observer.disconnect();
        }
      },
      { threshold: 0.1 }
    );

    if (imgRef.current) {
      observer.observe(imgRef.current);
    }

    return () => observer.disconnect();
  }, []);

  return (
    <div ref={imgRef} className={className}>
      {isInView && (
        <img
          src={src}
          alt={alt}
          onLoad={() => setIsLoaded(true)}
          style={{
            opacity: isLoaded ? 1 : 0,
            transition: 'opacity 0.3s'
          }}
        />
      )}
    </div>
  );
}

// 2. 이미지 압축 및 포맷 최적화
function OptimizedImage({ src, alt, width, height }) {
  const getOptimizedSrc = (originalSrc, w, h) => {
    // 이미지 CDN 사용 예시
    return `${originalSrc}?w=${w}&h=${h}&format=webp&quality=80`;
  };

  return (
    <picture>
      <source
        srcSet={getOptimizedSrc(src, width, height)}
        type="image/webp"
      />
      <img
        src={getOptimizedSrc(src, width, height)}
        alt={alt}
        width={width}
        height={height}
        loading="lazy"
      />
    </picture>
  );
}
```

### 캐싱 전략
```javascript
// Service Worker 캐싱 (선택사항)
// public/sw.js
const CACHE_NAME = 'jober-v1';
const urlsToCache = [
  '/',
  '/static/css/main.css',
  '/static/js/main.js'
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(urlsToCache))
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => {
        return response || fetch(event.request);
      })
  );
});

// HTTP 캐싱 헤더 설정 (Vite)
// vite.config.js
export default {
  server: {
    headers: {
      'Cache-Control': 'public, max-age=31536000'
    }
  }
}
```

## 🎨 렌더링 최적화

### 조건부 렌더링 최적화
```jsx
// 잘못된 예: 매번 새로운 객체/배열 생성
function BadComponent({ isLoading, data }) {
  return (
    <div>
      {isLoading ? <Spinner /> : null}
      {data.map(item => (
        <div key={item.id} style={{ padding: '10px' }}>
          {item.name}
        </div>
      ))}
    </div>
  );
}

// 올바른 예: 메모이제이션과 상수 활용
const itemStyle = { padding: '10px' };

const GoodComponent = React.memo(({ isLoading, data }) => {
  const renderedItems = useMemo(() =>
    data.map(item => (
      <div key={item.id} style={itemStyle}>
        {item.name}
      </div>
    )),
    [data]
  );

  if (isLoading) {
    return <Spinner />;
  }

  return <div>{renderedItems}</div>;
});
```

### CSS-in-JS 최적화
```jsx
// Tailwind CSS 조건부 클래스 최적화
import { clsx } from 'clsx';

function Button({ variant, size, isLoading, children }) {
  const buttonClasses = useMemo(() => clsx(
    'font-medium rounded-lg transition-colors',
    {
      'bg-blue-500 hover:bg-blue-600 text-white': variant === 'primary',
      'bg-gray-200 hover:bg-gray-300 text-gray-900': variant === 'secondary',
      'px-3 py-1.5 text-sm': size === 'small',
      'px-4 py-2': size === 'medium',
      'px-6 py-3 text-lg': size === 'large',
      'opacity-50 cursor-not-allowed': isLoading
    }
  ), [variant, size, isLoading]);

  return (
    <button className={buttonClasses} disabled={isLoading}>
      {isLoading ? '로딩 중...' : children}
    </button>
  );
}
```

## 💾 메모리 최적화

### 메모리 누수 방지
```jsx
// 1. useEffect 정리 함수
function ComponentWithInterval() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setCount(prev => prev + 1);
    }, 1000);

    // 정리 함수로 메모리 누수 방지
    return () => clearInterval(interval);
  }, []);

  return <div>Count: {count}</div>;
}

// 2. 이벤트 리스너 정리
function ComponentWithEventListener() {
  useEffect(() => {
    const handleResize = () => {
      console.log('Window resized');
    };

    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  return <div>Component with event listener</div>;
}

// 3. AbortController로 취소 가능한 요청
function ComponentWithAPI() {
  const [data, setData] = useState(null);

  useEffect(() => {
    const controller = new AbortController();

    fetch('/api/data', {
      signal: controller.signal
    })
    .then(response => response.json())
    .then(setData)
    .catch(error => {
      if (error.name !== 'AbortError') {
        console.error('Fetch error:', error);
      }
    });

    return () => {
      controller.abort();
    };
  }, []);

  return <div>{data ? JSON.stringify(data) : 'Loading...'}</div>;
}
```

### 큰 데이터 처리 최적화
```javascript
// Web Workers 활용
// workers/dataProcessor.js
self.onmessage = function(e) {
  const { data, operation } = e.data;

  let result;
  switch (operation) {
    case 'processTemplates':
      result = data.map(template => ({
        ...template,
        processedAt: Date.now(),
        wordCount: template.content.split(' ').length
      }));
      break;
    default:
      result = data;
  }

  self.postMessage(result);
};

// 메인 스레드에서 사용
function useWebWorker() {
  const workerRef = useRef();

  useEffect(() => {
    workerRef.current = new Worker('/workers/dataProcessor.js');
    return () => {
      workerRef.current.terminate();
    };
  }, []);

  const processData = useCallback((data, operation) => {
    return new Promise((resolve) => {
      workerRef.current.onmessage = (e) => {
        resolve(e.data);
      };
      workerRef.current.postMessage({ data, operation });
    });
  }, []);

  return { processData };
}
```

## 📊 성능 모니터링

### 실시간 성능 추적
```javascript
// 성능 지표 수집
class PerformanceMonitor {
  constructor() {
    this.metrics = {
      pageLoadTime: 0,
      renderTime: 0,
      apiResponseTimes: [],
      errorCount: 0
    };
  }

  // 페이지 로드 시간 측정
  measurePageLoad() {
    window.addEventListener('load', () => {
      const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;
      this.metrics.pageLoadTime = loadTime;
      this.sendMetrics('pageLoad', loadTime);
    });
  }

  // API 응답 시간 측정
  measureApiCall(url, startTime) {
    const endTime = performance.now();
    const responseTime = endTime - startTime;
    this.metrics.apiResponseTimes.push({
      url,
      responseTime,
      timestamp: Date.now()
    });

    if (responseTime > 3000) {
      this.sendMetrics('slowApi', { url, responseTime });
    }
  }

  // 에러 추적
  trackError(error) {
    this.metrics.errorCount++;
    this.sendMetrics('error', {
      message: error.message,
      stack: error.stack,
      timestamp: Date.now()
    });
  }

  // 메트릭 전송
  sendMetrics(type, data) {
    // 실제 모니터링 서비스로 전송
    fetch('/api/metrics', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ type, data, userAgent: navigator.userAgent })
    });
  }
}

// React 컴포넌트에서 사용
function usePerformanceMonitor() {
  const monitor = useRef(new PerformanceMonitor()).current;

  useEffect(() => {
    monitor.measurePageLoad();

    // 전역 에러 핸들링
    window.addEventListener('error', (e) => {
      monitor.trackError(e.error);
    });

    window.addEventListener('unhandledrejection', (e) => {
      monitor.trackError(new Error(e.reason));
    });
  }, [monitor]);

  return {
    measureApiCall: monitor.measureApiCall.bind(monitor),
    trackError: monitor.trackError.bind(monitor)
  };
}
```

### Core Web Vitals 모니터링
```javascript
// web-vitals 라이브러리 설치
// npm install web-vitals

import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

function sendToAnalytics(metric) {
  fetch('/api/analytics', {
    method: 'POST',
    body: JSON.stringify(metric)
  });
}

// 모든 주요 지표 측정
getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getFCP(sendToAnalytics);
getLCP(sendToAnalytics);
getTTFB(sendToAnalytics);
```

## ✅ 최적화 체크리스트

### 📦 번들 최적화
- [ ] 코드 스플리팅 구현 (라우트 기반)
- [ ] Tree shaking 활성화
- [ ] 사용하지 않는 의존성 제거
- [ ] 번들 크기 분석 및 최적화
- [ ] Tailwind CSS purge 설정

### ⚡ 런타임 최적화
- [ ] React.memo 적용 (적절한 컴포넌트)
- [ ] useMemo/useCallback 최적화
- [ ] 불필요한 리렌더링 제거
- [ ] 가상화 적용 (긴 리스트)
- [ ] 디바운싱/스로틀링 구현

### 🌐 네트워크 최적화
- [ ] 이미지 지연 로딩
- [ ] API 요청 최적화
- [ ] 캐싱 전략 구현
- [ ] 압축 설정
- [ ] CDN 사용 고려

### 🎨 렌더링 최적화
- [ ] 조건부 렌더링 최적화
- [ ] CSS 클래스 메모이제이션
- [ ] 인라인 스타일 최소화
- [ ] DOM 조작 최소화

### 💾 메모리 최적화
- [ ] useEffect 정리 함수 구현
- [ ] 이벤트 리스너 정리
- [ ] 메모리 누수 점검
- [ ] 큰 데이터 처리 최적화

### 📊 모니터링
- [ ] 성능 지표 수집 설정
- [ ] Core Web Vitals 모니터링
- [ ] 에러 추적 구현
- [ ] 정기적인 성능 감사

## 🎯 성능 목표

### 기본 목표
- **First Contentful Paint**: < 1.5초
- **Largest Contentful Paint**: < 2.5초
- **First Input Delay**: < 100ms
- **Cumulative Layout Shift**: < 0.1
- **번들 크기**: < 1MB (gzipped)

### 고급 목표
- **Time to Interactive**: < 3초
- **API 응답 시간**: < 500ms
- **메모리 사용량**: < 50MB
- **CPU 사용량**: < 20%

---

## 📚 추가 리소스

- [Web.dev Performance](https://web.dev/performance/)
- [React Performance Optimization](https://react.dev/learn/render-and-commit#optimizing-performance)
- [Vite Performance](https://vitejs.dev/guide/performance.html)
- [Bundle Analyzer](https://www.npmjs.com/package/rollup-plugin-visualizer)

---

*마지막 업데이트: 2024-09*
*문서 담당: Frontend Team*