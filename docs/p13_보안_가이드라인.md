# 보안 가이드라인

## 📋 목차
1. [보안 원칙](#보안-원칙)
2. [인증 및 인가](#인증-및-인가)
3. [데이터 보호](#데이터-보호)
4. [프론트엔드 보안](#프론트엔드-보안)
5. [API 통신 보안](#api-통신-보안)
6. [의존성 관리](#의존성-관리)
7. [보안 테스트](#보안-테스트)
8. [인시던트 대응](#인시던트-대응)
9. [보안 체크리스트](#보안-체크리스트)

## 🛡️ 보안 원칙

### 기본 보안 철학
1. **최소 권한 원칙**: 필요한 최소한의 권한만 부여
2. **심층 방어**: 여러 보안 계층 구성
3. **보안 기본값**: 기본적으로 안전한 설정 사용
4. **명시적 검증**: 모든 입력과 요청 검증
5. **투명성**: 보안 관련 로깅 및 모니터링

### 위협 모델링
```javascript
// 주요 위협 유형
const THREAT_CATEGORIES = {
  INJECTION: {
    type: 'Injection Attacks',
    examples: ['XSS', 'SQL Injection', 'Script Injection'],
    impact: 'High',
    likelihood: 'Medium'
  },
  BROKEN_AUTH: {
    type: 'Broken Authentication',
    examples: ['Weak passwords', 'Session hijacking', 'Token theft'],
    impact: 'High',
    likelihood: 'Medium'
  },
  SENSITIVE_DATA: {
    type: 'Sensitive Data Exposure',
    examples: ['Unencrypted data', 'Weak encryption', 'Data leaks'],
    impact: 'High',
    likelihood: 'Low'
  },
  BROKEN_ACCESS: {
    type: 'Broken Access Control',
    examples: ['Privilege escalation', 'Unauthorized access'],
    impact: 'High',
    likelihood: 'Medium'
  }
};
```

## 🔐 인증 및 인가

### JWT 토큰 관리
```javascript
// ✅ 안전한 토큰 저장 및 관리
class AuthService {
  constructor() {
    this.TOKEN_KEY = 'auth_token';
    this.REFRESH_TOKEN_KEY = 'refresh_token';
  }

  // 토큰 저장 (HttpOnly 쿠키 권장, 여기서는 localStorage 예시)
  storeTokens(accessToken, refreshToken) {
    // 액세스 토큰: 짧은 만료 시간 (15분)
    localStorage.setItem(this.TOKEN_KEY, accessToken);

    // 리프레시 토큰: HttpOnly 쿠키에 저장 (권장)
    // 여기서는 localStorage 예시 (실제로는 서버에서 HttpOnly 쿠키로 설정)
    localStorage.setItem(this.REFRESH_TOKEN_KEY, refreshToken);
  }

  // 토큰 검증
  validateToken(token) {
    if (!token) return false;

    try {
      // JWT 디코딩 (서명 검증은 서버에서)
      const payload = JSON.parse(atob(token.split('.')[1]));
      const now = Date.now() / 1000;

      return payload.exp > now;
    } catch (error) {
      console.error('토큰 검증 실패:', error);
      return false;
    }
  }

  // 자동 토큰 갱신
  async refreshAccessToken() {
    const refreshToken = localStorage.getItem(this.REFRESH_TOKEN_KEY);

    if (!refreshToken || !this.validateToken(refreshToken)) {
      this.logout();
      throw new Error('로그인이 필요합니다');
    }

    try {
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ refreshToken })
      });

      if (!response.ok) {
        throw new Error('토큰 갱신 실패');
      }

      const { accessToken, refreshToken: newRefreshToken } = await response.json();
      this.storeTokens(accessToken, newRefreshToken);

      return accessToken;
    } catch (error) {
      this.logout();
      throw error;
    }
  }

  // 안전한 로그아웃
  logout() {
    localStorage.removeItem(this.TOKEN_KEY);
    localStorage.removeItem(this.REFRESH_TOKEN_KEY);

    // 서버에 로그아웃 알림 (토큰 무효화)
    fetch('/api/auth/logout', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.getToken()}`
      }
    }).catch(console.error);
  }
}
```

### 권한 기반 접근 제어
```javascript
// 역할 기반 권한 시스템
const ROLES = {
  ADMIN: 'admin',
  MANAGER: 'manager',
  USER: 'user'
};

const PERMISSIONS = {
  TEMPLATE_CREATE: 'template:create',
  TEMPLATE_APPROVE: 'template:approve',
  TEMPLATE_DELETE: 'template:delete',
  STATISTICS_VIEW: 'statistics:view',
  USER_MANAGE: 'user:manage'
};

const ROLE_PERMISSIONS = {
  [ROLES.ADMIN]: Object.values(PERMISSIONS),
  [ROLES.MANAGER]: [
    PERMISSIONS.TEMPLATE_APPROVE,
    PERMISSIONS.STATISTICS_VIEW,
    PERMISSIONS.TEMPLATE_DELETE
  ],
  [ROLES.USER]: [
    PERMISSIONS.TEMPLATE_CREATE
  ]
};

// 권한 확인 훅
function usePermissions() {
  const { user } = useAuthStore();

  const hasPermission = useCallback((permission) => {
    if (!user || !user.role) return false;

    const rolePermissions = ROLE_PERMISSIONS[user.role] || [];
    return rolePermissions.includes(permission);
  }, [user]);

  const hasAnyPermission = useCallback((permissions) => {
    return permissions.some(permission => hasPermission(permission));
  }, [hasPermission]);

  return { hasPermission, hasAnyPermission };
}

// 보호된 컴포넌트
const ProtectedComponent = ({ permission, fallback = null, children }) => {
  const { hasPermission } = usePermissions();

  if (!hasPermission(permission)) {
    return fallback;
  }

  return children;
};

// 사용 예시
const TemplateActions = ({ template }) => {
  return (
    <div className="template-actions">
      <ProtectedComponent permission={PERMISSIONS.TEMPLATE_APPROVE}>
        <button onClick={() => approveTemplate(template.id)}>
          승인
        </button>
      </ProtectedComponent>

      <ProtectedComponent permission={PERMISSIONS.TEMPLATE_DELETE}>
        <button onClick={() => deleteTemplate(template.id)}>
          삭제
        </button>
      </ProtectedComponent>
    </div>
  );
};
```

## 🔒 데이터 보호

### 입력 검증 및 새니타이징
```javascript
// 입력 검증 유틸리티
class InputValidator {
  // XSS 방지를 위한 HTML 새니타이징
  static sanitizeHtml(input) {
    const div = document.createElement('div');
    div.textContent = input;
    return div.innerHTML;
  }

  // 이메일 검증
  static validateEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email) && email.length <= 254;
  }

  // 템플릿 내용 검증
  static validateTemplateContent(content) {
    if (!content || typeof content !== 'string') {
      throw new ValidationError('유효하지 않은 템플릿 내용입니다');
    }

    // 길이 제한
    if (content.length > 2000) {
      throw new ValidationError('템플릿 내용이 너무 깁니다 (최대 2000자)');
    }

    // 위험한 스크립트 패턴 검사
    const dangerousPatterns = [
      /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
      /javascript:/gi,
      /vbscript:/gi,
      /on\w+\s*=/gi
    ];

    for (const pattern of dangerousPatterns) {
      if (pattern.test(content)) {
        throw new ValidationError('허용되지 않는 스크립트가 포함되어 있습니다');
      }
    }

    return this.sanitizeHtml(content);
  }

  // SQL 인젝션 방지 (프론트엔드에서는 기본적인 검증만)
  static validateSearchQuery(query) {
    if (!query || typeof query !== 'string') {
      return '';
    }

    // 위험한 SQL 키워드 제거
    const sqlKeywords = [
      'DROP', 'DELETE', 'INSERT', 'UPDATE', 'CREATE', 'ALTER',
      'EXEC', 'UNION', 'SELECT', 'SCRIPT', '--', ';'
    ];

    let sanitized = query;
    sqlKeywords.forEach(keyword => {
      const regex = new RegExp(keyword, 'gi');
      sanitized = sanitized.replace(regex, '');
    });

    return sanitized.trim().substring(0, 100);
  }
}

// 폼 검증 훅
function useFormValidation(schema) {
  const [errors, setErrors] = useState({});

  const validate = useCallback((data) => {
    const newErrors = {};

    Object.keys(schema).forEach(field => {
      const rules = schema[field];
      const value = data[field];

      try {
        if (rules.required && (!value || value.trim() === '')) {
          newErrors[field] = `${field}는 필수 입력입니다`;
          return;
        }

        if (rules.validator && value) {
          rules.validator(value);
        }
      } catch (error) {
        newErrors[field] = error.message;
      }
    });

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  }, [schema]);

  return { errors, validate };
}
```

### 민감한 데이터 처리
```javascript
// 민감한 정보 마스킹
class DataMasking {
  static maskEmail(email) {
    if (!email) return '';

    const [username, domain] = email.split('@');
    if (username.length <= 3) {
      return `${username[0]}***@${domain}`;
    }

    return `${username.substring(0, 3)}***@${domain}`;
  }

  static maskPhoneNumber(phone) {
    if (!phone) return '';

    const cleaned = phone.replace(/\D/g, '');
    if (cleaned.length === 11) {
      return `${cleaned.substring(0, 3)}-****-${cleaned.substring(7)}`;
    }

    return '***-****-****';
  }

  static maskCreditCard(cardNumber) {
    if (!cardNumber) return '';

    const cleaned = cardNumber.replace(/\D/g, '');
    if (cleaned.length >= 12) {
      return `****-****-****-${cleaned.substring(cleaned.length - 4)}`;
    }

    return '****-****-****-****';
  }
}

// 개인정보 로깅 방지
class SecureLogger {
  static sensitiveFields = [
    'password', 'token', 'secret', 'key',
    'email', 'phone', 'ssn', 'cardNumber'
  ];

  static sanitizeLogData(data) {
    if (typeof data !== 'object' || data === null) {
      return data;
    }

    const sanitized = { ...data };

    Object.keys(sanitized).forEach(key => {
      if (this.sensitiveFields.some(field =>
        key.toLowerCase().includes(field.toLowerCase())
      )) {
        sanitized[key] = '[REDACTED]';
      }
    });

    return sanitized;
  }

  static log(level, message, data = {}) {
    const sanitizedData = this.sanitizeLogData(data);
    console[level](`[${new Date().toISOString()}] ${message}`, sanitizedData);
  }
}
```

## 🌐 프론트엔드 보안

### CSP (Content Security Policy) 설정
```html
<!-- index.html에 CSP 헤더 설정 -->
<meta http-equiv="Content-Security-Policy" content="
  default-src 'self';
  script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net;
  style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
  font-src 'self' https://fonts.gstatic.com;
  img-src 'self' data: https:;
  connect-src 'self' https://api.yourservice.com;
  object-src 'none';
  base-uri 'self';
  form-action 'self';
">
```

### XSS 방지
```javascript
// React에서 dangerouslySetInnerHTML 안전하게 사용
import DOMPurify from 'dompurify';

const SafeHtmlContent = ({ htmlContent }) => {
  const sanitizedHtml = useMemo(() => {
    return DOMPurify.sanitize(htmlContent, {
      ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u'],
      ALLOWED_ATTR: []
    });
  }, [htmlContent]);

  return (
    <div
      dangerouslySetInnerHTML={{ __html: sanitizedHtml }}
    />
  );
};

// URL 파라미터 검증
function useSafeUrlParams() {
  const params = useParams();

  const safeParams = useMemo(() => {
    const safe = {};

    Object.keys(params).forEach(key => {
      // URL 파라미터 새니타이징
      safe[key] = InputValidator.sanitizeHtml(params[key] || '');
    });

    return safe;
  }, [params]);

  return safeParams;
}
```

### CSRF 방지
```javascript
// CSRF 토큰 관리
class CSRFProtection {
  static async getCSRFToken() {
    try {
      const response = await fetch('/api/csrf-token', {
        credentials: 'include'
      });
      const data = await response.json();
      return data.csrfToken;
    } catch (error) {
      console.error('CSRF 토큰 획득 실패:', error);
      return null;
    }
  }

  static async makeSecureRequest(url, options = {}) {
    const csrfToken = await this.getCSRFToken();

    return fetch(url, {
      ...options,
      credentials: 'include',
      headers: {
        ...options.headers,
        'X-CSRF-Token': csrfToken,
        'Content-Type': 'application/json'
      }
    });
  }
}

// 안전한 API 클라이언트
class SecureApiClient {
  constructor() {
    this.baseUrl = process.env.REACT_APP_API_URL;
  }

  async request(endpoint, options = {}) {
    const url = `${this.baseUrl}${endpoint}`;

    // CSRF 보호 및 인증 토큰 추가
    const secureOptions = {
      ...options,
      credentials: 'include',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${AuthService.getToken()}`,
        ...options.headers
      }
    };

    try {
      const response = await CSRFProtection.makeSecureRequest(url, secureOptions);

      if (!response.ok) {
        if (response.status === 401) {
          // 토큰 갱신 시도
          await AuthService.refreshAccessToken();
          // 재시도
          return this.request(endpoint, options);
        }
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      SecureLogger.log('error', 'API 요청 실패', {
        endpoint,
        error: error.message
      });
      throw error;
    }
  }
}
```

## 📡 API 통신 보안

### HTTPS 강제 사용
```javascript
// HTTPS 리다이렉션 확인
function enforceHTTPS() {
  if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
    location.replace('https:' + window.location.href.substring(window.location.protocol.length));
  }
}

// 개발 환경에서만 HTTP 허용
const API_BASE_URL = process.env.NODE_ENV === 'production'
  ? 'https://api.yourservice.com'
  : process.env.REACT_APP_API_URL;
```

### 요청 무결성 검증
```javascript
// API 요청 서명 (선택적 보안 강화)
class RequestSigner {
  static async signRequest(data, secretKey) {
    const encoder = new TextEncoder();
    const keyData = encoder.encode(secretKey);
    const dataString = JSON.stringify(data);
    const dataBuffer = encoder.encode(dataString);

    const cryptoKey = await crypto.subtle.importKey(
      'raw',
      keyData,
      { name: 'HMAC', hash: 'SHA-256' },
      false,
      ['sign']
    );

    const signature = await crypto.subtle.sign('HMAC', cryptoKey, dataBuffer);
    return Array.from(new Uint8Array(signature))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }

  static async makeSignedRequest(url, data) {
    const timestamp = Date.now();
    const nonce = crypto.getRandomValues(new Uint32Array(1))[0].toString(16);

    const requestData = {
      ...data,
      timestamp,
      nonce
    };

    const signature = await this.signRequest(requestData, process.env.REACT_APP_API_SECRET);

    return fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Signature': signature,
        'X-Timestamp': timestamp.toString(),
        'X-Nonce': nonce
      },
      body: JSON.stringify(requestData)
    });
  }
}
```

## 📦 의존성 관리

### 취약점 스캔 및 관리
```bash
# 정기적인 보안 감사
npm audit
npm audit fix

# 고위험 취약점 확인
npm audit --audit-level high

# package-lock.json 보안
npm ci  # npm install 대신 사용 (더 안전)
```

### 신뢰할 수 있는 패키지 사용
```javascript
// package.json에서 패키지 검증
{
  "dependencies": {
    "react": "^18.2.0",        // 메이저 버전만 업데이트
    "lodash": "~4.17.21"       // 패치 버전만 업데이트
  },
  "resolutions": {
    "minimist": "^1.2.6"       // 취약한 하위 의존성 강제 업데이트
  }
}

// 런타임 의존성 검증
class DependencyValidator {
  static validatePackage(packageName, expectedVersion) {
    try {
      const packageJson = require(`${packageName}/package.json`);
      const actualVersion = packageJson.version;

      if (!this.isVersionCompatible(actualVersion, expectedVersion)) {
        throw new Error(`보안 위험: ${packageName} 버전 불일치`);
      }

      return true;
    } catch (error) {
      SecureLogger.log('warn', '패키지 검증 실패', {
        packageName,
        expectedVersion,
        error: error.message
      });
      return false;
    }
  }

  static isVersionCompatible(actual, expected) {
    // 간단한 버전 호환성 검사
    return actual.startsWith(expected.replace(/[~^]/, ''));
  }
}
```

## 🧪 보안 테스트

### 자동화된 보안 테스트
```javascript
// Jest를 이용한 보안 테스트
describe('보안 테스트', () => {
  describe('입력 검증', () => {
    test('XSS 공격 스크립트를 차단해야 함', () => {
      const maliciousInput = '<script>alert("XSS")</script>';
      const sanitized = InputValidator.sanitizeHtml(maliciousInput);

      expect(sanitized).not.toContain('<script>');
      expect(sanitized).not.toContain('alert');
    });

    test('SQL 인젝션 패턴을 제거해야 함', () => {
      const maliciousQuery = "'; DROP TABLE users; --";
      const sanitized = InputValidator.validateSearchQuery(maliciousQuery);

      expect(sanitized).not.toContain('DROP');
      expect(sanitized).not.toContain('--');
    });

    test('템플릿 내용 길이 제한을 확인해야 함', () => {
      const longContent = 'a'.repeat(2001);

      expect(() => {
        InputValidator.validateTemplateContent(longContent);
      }).toThrow('템플릿 내용이 너무 깁니다');
    });
  });

  describe('인증', () => {
    test('만료된 토큰을 거부해야 함', () => {
      const expiredToken = generateExpiredToken();

      expect(AuthService.validateToken(expiredToken)).toBe(false);
    });

    test('잘못된 형식의 토큰을 거부해야 함', () => {
      const invalidToken = 'invalid.token.format';

      expect(AuthService.validateToken(invalidToken)).toBe(false);
    });
  });

  describe('권한', () => {
    test('권한이 없는 사용자의 접근을 차단해야 함', () => {
      const user = { role: 'user' };
      const hasPermission = checkPermission(user, PERMISSIONS.TEMPLATE_APPROVE);

      expect(hasPermission).toBe(false);
    });
  });
});

// 보안 통합 테스트
describe('보안 통합 테스트', () => {
  test('보호된 라우트 접근 테스트', async () => {
    render(<App />);

    // 로그인하지 않은 상태에서 보호된 페이지 접근
    fireEvent.click(screen.getByText('대시보드'));

    // 로그인 페이지로 리다이렉트되어야 함
    await waitFor(() => {
      expect(screen.getByText('로그인')).toBeInTheDocument();
    });
  });
});
```

### 침투 테스트 체크리스트
```markdown
## 수동 보안 테스트

### 인증 우회 시도
- [ ] 토큰 없이 보호된 API 접근
- [ ] 만료된 토큰으로 접근
- [ ] 다른 사용자의 토큰 사용
- [ ] 로그아웃 후 토큰 재사용

### 권한 에스컬레이션
- [ ] URL 직접 접근으로 권한 우회
- [ ] API 요청에서 role 파라미터 조작
- [ ] 다른 사용자의 데이터 접근

### 입력 검증 우회
- [ ] XSS 스크립트 삽입
- [ ] SQL 인젝션 시도
- [ ] 파일 업로드 검증 우회
- [ ] 파라미터 오염 공격

### 세션 관리
- [ ] 세션 고정 공격
- [ ] 세션 하이재킹
- [ ] 동시 로그인 처리
- [ ] 자동 로그아웃 확인
```

## 🚨 인시던트 대응

### 보안 사고 대응 절차
```javascript
// 보안 사고 감지 및 대응
class SecurityIncidentManager {
  static INCIDENT_TYPES = {
    UNAUTHORIZED_ACCESS: 'unauthorized_access',
    DATA_BREACH: 'data_breach',
    XSS_ATTACK: 'xss_attack',
    BRUTE_FORCE: 'brute_force'
  };

  static detectSuspiciousActivity(activity) {
    const suspiciousPatterns = [
      {
        pattern: /admin|root|system/i,
        type: this.INCIDENT_TYPES.UNAUTHORIZED_ACCESS
      },
      {
        pattern: /<script|javascript:|vbscript:/i,
        type: this.INCIDENT_TYPES.XSS_ATTACK
      }
    ];

    for (const { pattern, type } of suspiciousPatterns) {
      if (pattern.test(activity.data)) {
        this.reportIncident(type, activity);
        return true;
      }
    }

    return false;
  }

  static reportIncident(type, details) {
    const incident = {
      id: crypto.randomUUID(),
      type,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: window.location.href,
      details: this.sanitizeIncidentData(details)
    };

    // 즉시 서버에 보고
    fetch('/api/security/incidents', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(incident)
    }).catch(console.error);

    // 로컬 로깅
    SecureLogger.log('error', `보안 사고 감지: ${type}`, incident);

    // 심각한 사고의 경우 즉시 로그아웃
    if (type === this.INCIDENT_TYPES.DATA_BREACH) {
      AuthService.logout();
      window.location.href = '/login?reason=security';
    }
  }

  static sanitizeIncidentData(data) {
    // 민감한 정보 제거
    return SecureLogger.sanitizeLogData(data);
  }
}

// 실시간 보안 모니터링
class SecurityMonitor {
  constructor() {
    this.failedLoginAttempts = 0;
    this.lastFailedLogin = null;
    this.isMonitoring = true;
  }

  startMonitoring() {
    // 의심스러운 활동 모니터링
    window.addEventListener('error', (event) => {
      if (this.isSuspiciousError(event.error)) {
        SecurityIncidentManager.reportIncident(
          SecurityIncidentManager.INCIDENT_TYPES.XSS_ATTACK,
          { error: event.error.message }
        );
      }
    });

    // 비정상적인 네트워크 요청 모니터링
    this.monitorNetworkRequests();
  }

  monitorNetworkRequests() {
    const originalFetch = window.fetch;
    window.fetch = async (...args) => {
      const response = await originalFetch(...args);

      if (response.status === 401) {
        this.handleUnauthorizedAccess();
      }

      return response;
    };
  }

  handleUnauthorizedAccess() {
    this.failedLoginAttempts++;
    this.lastFailedLogin = Date.now();

    // 연속 실패 시 계정 보호
    if (this.failedLoginAttempts >= 5) {
      SecurityIncidentManager.reportIncident(
        SecurityIncidentManager.INCIDENT_TYPES.BRUTE_FORCE,
        { attempts: this.failedLoginAttempts }
      );

      // 일시적 접근 차단
      this.blockAccess(15 * 60 * 1000); // 15분
    }
  }

  blockAccess(duration) {
    localStorage.setItem('accessBlocked', Date.now() + duration);
    window.location.href = '/blocked';
  }

  isSuspiciousError(error) {
    const suspiciousMessages = [
      'script error',
      'permission denied',
      'access denied',
      'unauthorized'
    ];

    return suspiciousMessages.some(msg =>
      error.message.toLowerCase().includes(msg)
    );
  }
}
```

## ✅ 보안 체크리스트

### 개발 단계
- [ ] **입력 검증**: 모든 사용자 입력 검증 및 새니타이징
- [ ] **출력 인코딩**: XSS 방지를 위한 적절한 인코딩
- [ ] **인증 구현**: 강력한 인증 메커니즘 구현
- [ ] **권한 제어**: 최소 권한 원칙 적용
- [ ] **세션 관리**: 안전한 세션 처리
- [ ] **HTTPS 사용**: 모든 통신에 HTTPS 적용
- [ ] **CSP 설정**: Content Security Policy 구성
- [ ] **의존성 검사**: 취약한 패키지 확인 및 업데이트

### 테스트 단계
- [ ] **자동화된 보안 테스트**: 단위/통합 테스트에 보안 검증 포함
- [ ] **침투 테스트**: 수동 보안 테스트 수행
- [ ] **코드 감사**: 정적 코드 분석 도구 사용
- [ ] **의존성 감사**: npm audit 등으로 취약점 스캔

### 배포 단계
- [ ] **환경 변수 보안**: 민감한 정보를 환경 변수로 관리
- [ ] **로깅 설정**: 보안 관련 이벤트 로깅
- [ ] **모니터링 구성**: 실시간 보안 모니터링 설정
- [ ] **백업 및 복구**: 보안 사고 대응 계획 수립

### 운영 단계
- [ ] **정기 감사**: 주기적인 보안 점검
- [ ] **취약점 관리**: 새로운 취약점 모니터링 및 패치
- [ ] **사고 대응**: 보안 사고 대응 절차 점검
- [ ] **교육 및 훈련**: 팀원 보안 교육

---

## 📚 보안 리소스

### 참고 문서
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [React Security Best Practices](https://react.dev/learn/javascript-in-jsx-with-curly-braces#using-double-curlies-css-and-other-objects)
- [Web Security Guidelines](https://web.dev/security/)

### 보안 도구
- **ESLint Security Plugin**: eslint-plugin-security
- **Dependency Scanner**: npm audit, Snyk
- **Static Analysis**: SonarQube, CodeQL
- **Runtime Protection**: Content Security Policy

### 보안 커뮤니티
- [한국인터넷진흥원(KISA)](https://www.kisa.or.kr/)
- [OWASP Korea](https://owasp.org/www-chapter-korea/)
- [보안뉴스](https://www.boannews.com/)

---

*마지막 업데이트: 2024-09*
*문서 담당: Security Team*