# ë³´ì•ˆ ê°€ì´ë“œë¼ì¸

## ğŸ“‹ ëª©ì°¨
1. [ë³´ì•ˆ ì›ì¹™](#ë³´ì•ˆ-ì›ì¹™)
2. [ì¸ì¦ ë° ì¸ê°€](#ì¸ì¦-ë°-ì¸ê°€)
3. [ë°ì´í„° ë³´í˜¸](#ë°ì´í„°-ë³´í˜¸)
4. [í”„ë¡ íŠ¸ì—”ë“œ ë³´ì•ˆ](#í”„ë¡ íŠ¸ì—”ë“œ-ë³´ì•ˆ)
5. [API í†µì‹  ë³´ì•ˆ](#api-í†µì‹ -ë³´ì•ˆ)
6. [ì˜ì¡´ì„± ê´€ë¦¬](#ì˜ì¡´ì„±-ê´€ë¦¬)
7. [ë³´ì•ˆ í…ŒìŠ¤íŠ¸](#ë³´ì•ˆ-í…ŒìŠ¤íŠ¸)
8. [ì¸ì‹œë˜íŠ¸ ëŒ€ì‘](#ì¸ì‹œë˜íŠ¸-ëŒ€ì‘)
9. [ë³´ì•ˆ ì²´í¬ë¦¬ìŠ¤íŠ¸](#ë³´ì•ˆ-ì²´í¬ë¦¬ìŠ¤íŠ¸)

## ğŸ›¡ï¸ ë³´ì•ˆ ì›ì¹™

### ê¸°ë³¸ ë³´ì•ˆ ì² í•™
1. **ìµœì†Œ ê¶Œí•œ ì›ì¹™**: í•„ìš”í•œ ìµœì†Œí•œì˜ ê¶Œí•œë§Œ ë¶€ì—¬
2. **ì‹¬ì¸µ ë°©ì–´**: ì—¬ëŸ¬ ë³´ì•ˆ ê³„ì¸µ êµ¬ì„±
3. **ë³´ì•ˆ ê¸°ë³¸ê°’**: ê¸°ë³¸ì ìœ¼ë¡œ ì•ˆì „í•œ ì„¤ì • ì‚¬ìš©
4. **ëª…ì‹œì  ê²€ì¦**: ëª¨ë“  ì…ë ¥ê³¼ ìš”ì²­ ê²€ì¦
5. **íˆ¬ëª…ì„±**: ë³´ì•ˆ ê´€ë ¨ ë¡œê¹… ë° ëª¨ë‹ˆí„°ë§

### ìœ„í˜‘ ëª¨ë¸ë§
```javascript
// ì£¼ìš” ìœ„í˜‘ ìœ í˜•
const THREAT_CATEGORIES = {
  INJECTION: {
    type: 'Injection Attacks',
    examples: ['XSS', 'SQL Injection', 'Script Injection'],
    impact: 'High',
    likelihood: 'Medium'
  },
  BROKEN_AUTH: {
    type: 'Broken Authentication',
    examples: ['Weak passwords', 'Session hijacking', 'Token theft'],
    impact: 'High',
    likelihood: 'Medium'
  },
  SENSITIVE_DATA: {
    type: 'Sensitive Data Exposure',
    examples: ['Unencrypted data', 'Weak encryption', 'Data leaks'],
    impact: 'High',
    likelihood: 'Low'
  },
  BROKEN_ACCESS: {
    type: 'Broken Access Control',
    examples: ['Privilege escalation', 'Unauthorized access'],
    impact: 'High',
    likelihood: 'Medium'
  }
};
```

## ğŸ” ì¸ì¦ ë° ì¸ê°€

### JWT í† í° ê´€ë¦¬
```javascript
// âœ… ì•ˆì „í•œ í† í° ì €ì¥ ë° ê´€ë¦¬
class AuthService {
  constructor() {
    this.TOKEN_KEY = 'auth_token';
    this.REFRESH_TOKEN_KEY = 'refresh_token';
  }

  // í† í° ì €ì¥ (HttpOnly ì¿ í‚¤ ê¶Œì¥, ì—¬ê¸°ì„œëŠ” localStorage ì˜ˆì‹œ)
  storeTokens(accessToken, refreshToken) {
    // ì•¡ì„¸ìŠ¤ í† í°: ì§§ì€ ë§Œë£Œ ì‹œê°„ (15ë¶„)
    localStorage.setItem(this.TOKEN_KEY, accessToken);

    // ë¦¬í”„ë ˆì‹œ í† í°: HttpOnly ì¿ í‚¤ì— ì €ì¥ (ê¶Œì¥)
    // ì—¬ê¸°ì„œëŠ” localStorage ì˜ˆì‹œ (ì‹¤ì œë¡œëŠ” ì„œë²„ì—ì„œ HttpOnly ì¿ í‚¤ë¡œ ì„¤ì •)
    localStorage.setItem(this.REFRESH_TOKEN_KEY, refreshToken);
  }

  // í† í° ê²€ì¦
  validateToken(token) {
    if (!token) return false;

    try {
      // JWT ë””ì½”ë”© (ì„œëª… ê²€ì¦ì€ ì„œë²„ì—ì„œ)
      const payload = JSON.parse(atob(token.split('.')[1]));
      const now = Date.now() / 1000;

      return payload.exp > now;
    } catch (error) {
      console.error('í† í° ê²€ì¦ ì‹¤íŒ¨:', error);
      return false;
    }
  }

  // ìë™ í† í° ê°±ì‹ 
  async refreshAccessToken() {
    const refreshToken = localStorage.getItem(this.REFRESH_TOKEN_KEY);

    if (!refreshToken || !this.validateToken(refreshToken)) {
      this.logout();
      throw new Error('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤');
    }

    try {
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ refreshToken })
      });

      if (!response.ok) {
        throw new Error('í† í° ê°±ì‹  ì‹¤íŒ¨');
      }

      const { accessToken, refreshToken: newRefreshToken } = await response.json();
      this.storeTokens(accessToken, newRefreshToken);

      return accessToken;
    } catch (error) {
      this.logout();
      throw error;
    }
  }

  // ì•ˆì „í•œ ë¡œê·¸ì•„ì›ƒ
  logout() {
    localStorage.removeItem(this.TOKEN_KEY);
    localStorage.removeItem(this.REFRESH_TOKEN_KEY);

    // ì„œë²„ì— ë¡œê·¸ì•„ì›ƒ ì•Œë¦¼ (í† í° ë¬´íš¨í™”)
    fetch('/api/auth/logout', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.getToken()}`
      }
    }).catch(console.error);
  }
}
```

### ê¶Œí•œ ê¸°ë°˜ ì ‘ê·¼ ì œì–´
```javascript
// ì—­í•  ê¸°ë°˜ ê¶Œí•œ ì‹œìŠ¤í…œ
const ROLES = {
  ADMIN: 'admin',
  MANAGER: 'manager',
  USER: 'user'
};

const PERMISSIONS = {
  TEMPLATE_CREATE: 'template:create',
  TEMPLATE_APPROVE: 'template:approve',
  TEMPLATE_DELETE: 'template:delete',
  STATISTICS_VIEW: 'statistics:view',
  USER_MANAGE: 'user:manage'
};

const ROLE_PERMISSIONS = {
  [ROLES.ADMIN]: Object.values(PERMISSIONS),
  [ROLES.MANAGER]: [
    PERMISSIONS.TEMPLATE_APPROVE,
    PERMISSIONS.STATISTICS_VIEW,
    PERMISSIONS.TEMPLATE_DELETE
  ],
  [ROLES.USER]: [
    PERMISSIONS.TEMPLATE_CREATE
  ]
};

// ê¶Œí•œ í™•ì¸ í›…
function usePermissions() {
  const { user } = useAuthStore();

  const hasPermission = useCallback((permission) => {
    if (!user || !user.role) return false;

    const rolePermissions = ROLE_PERMISSIONS[user.role] || [];
    return rolePermissions.includes(permission);
  }, [user]);

  const hasAnyPermission = useCallback((permissions) => {
    return permissions.some(permission => hasPermission(permission));
  }, [hasPermission]);

  return { hasPermission, hasAnyPermission };
}

// ë³´í˜¸ëœ ì»´í¬ë„ŒíŠ¸
const ProtectedComponent = ({ permission, fallback = null, children }) => {
  const { hasPermission } = usePermissions();

  if (!hasPermission(permission)) {
    return fallback;
  }

  return children;
};

// ì‚¬ìš© ì˜ˆì‹œ
const TemplateActions = ({ template }) => {
  return (
    <div className="template-actions">
      <ProtectedComponent permission={PERMISSIONS.TEMPLATE_APPROVE}>
        <button onClick={() => approveTemplate(template.id)}>
          ìŠ¹ì¸
        </button>
      </ProtectedComponent>

      <ProtectedComponent permission={PERMISSIONS.TEMPLATE_DELETE}>
        <button onClick={() => deleteTemplate(template.id)}>
          ì‚­ì œ
        </button>
      </ProtectedComponent>
    </div>
  );
};
```

## ğŸ”’ ë°ì´í„° ë³´í˜¸

### ì…ë ¥ ê²€ì¦ ë° ìƒˆë‹ˆíƒ€ì´ì§•
```javascript
// ì…ë ¥ ê²€ì¦ ìœ í‹¸ë¦¬í‹°
class InputValidator {
  // XSS ë°©ì§€ë¥¼ ìœ„í•œ HTML ìƒˆë‹ˆíƒ€ì´ì§•
  static sanitizeHtml(input) {
    const div = document.createElement('div');
    div.textContent = input;
    return div.innerHTML;
  }

  // ì´ë©”ì¼ ê²€ì¦
  static validateEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email) && email.length <= 254;
  }

  // í…œí”Œë¦¿ ë‚´ìš© ê²€ì¦
  static validateTemplateContent(content) {
    if (!content || typeof content !== 'string') {
      throw new ValidationError('ìœ íš¨í•˜ì§€ ì•Šì€ í…œí”Œë¦¿ ë‚´ìš©ì…ë‹ˆë‹¤');
    }

    // ê¸¸ì´ ì œí•œ
    if (content.length > 2000) {
      throw new ValidationError('í…œí”Œë¦¿ ë‚´ìš©ì´ ë„ˆë¬´ ê¹ë‹ˆë‹¤ (ìµœëŒ€ 2000ì)');
    }

    // ìœ„í—˜í•œ ìŠ¤í¬ë¦½íŠ¸ íŒ¨í„´ ê²€ì‚¬
    const dangerousPatterns = [
      /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
      /javascript:/gi,
      /vbscript:/gi,
      /on\w+\s*=/gi
    ];

    for (const pattern of dangerousPatterns) {
      if (pattern.test(content)) {
        throw new ValidationError('í—ˆìš©ë˜ì§€ ì•ŠëŠ” ìŠ¤í¬ë¦½íŠ¸ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤');
      }
    }

    return this.sanitizeHtml(content);
  }

  // SQL ì¸ì ì…˜ ë°©ì§€ (í”„ë¡ íŠ¸ì—”ë“œì—ì„œëŠ” ê¸°ë³¸ì ì¸ ê²€ì¦ë§Œ)
  static validateSearchQuery(query) {
    if (!query || typeof query !== 'string') {
      return '';
    }

    // ìœ„í—˜í•œ SQL í‚¤ì›Œë“œ ì œê±°
    const sqlKeywords = [
      'DROP', 'DELETE', 'INSERT', 'UPDATE', 'CREATE', 'ALTER',
      'EXEC', 'UNION', 'SELECT', 'SCRIPT', '--', ';'
    ];

    let sanitized = query;
    sqlKeywords.forEach(keyword => {
      const regex = new RegExp(keyword, 'gi');
      sanitized = sanitized.replace(regex, '');
    });

    return sanitized.trim().substring(0, 100);
  }
}

// í¼ ê²€ì¦ í›…
function useFormValidation(schema) {
  const [errors, setErrors] = useState({});

  const validate = useCallback((data) => {
    const newErrors = {};

    Object.keys(schema).forEach(field => {
      const rules = schema[field];
      const value = data[field];

      try {
        if (rules.required && (!value || value.trim() === '')) {
          newErrors[field] = `${field}ëŠ” í•„ìˆ˜ ì…ë ¥ì…ë‹ˆë‹¤`;
          return;
        }

        if (rules.validator && value) {
          rules.validator(value);
        }
      } catch (error) {
        newErrors[field] = error.message;
      }
    });

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  }, [schema]);

  return { errors, validate };
}
```

### ë¯¼ê°í•œ ë°ì´í„° ì²˜ë¦¬
```javascript
// ë¯¼ê°í•œ ì •ë³´ ë§ˆìŠ¤í‚¹
class DataMasking {
  static maskEmail(email) {
    if (!email) return '';

    const [username, domain] = email.split('@');
    if (username.length <= 3) {
      return `${username[0]}***@${domain}`;
    }

    return `${username.substring(0, 3)}***@${domain}`;
  }

  static maskPhoneNumber(phone) {
    if (!phone) return '';

    const cleaned = phone.replace(/\D/g, '');
    if (cleaned.length === 11) {
      return `${cleaned.substring(0, 3)}-****-${cleaned.substring(7)}`;
    }

    return '***-****-****';
  }

  static maskCreditCard(cardNumber) {
    if (!cardNumber) return '';

    const cleaned = cardNumber.replace(/\D/g, '');
    if (cleaned.length >= 12) {
      return `****-****-****-${cleaned.substring(cleaned.length - 4)}`;
    }

    return '****-****-****-****';
  }
}

// ê°œì¸ì •ë³´ ë¡œê¹… ë°©ì§€
class SecureLogger {
  static sensitiveFields = [
    'password', 'token', 'secret', 'key',
    'email', 'phone', 'ssn', 'cardNumber'
  ];

  static sanitizeLogData(data) {
    if (typeof data !== 'object' || data === null) {
      return data;
    }

    const sanitized = { ...data };

    Object.keys(sanitized).forEach(key => {
      if (this.sensitiveFields.some(field =>
        key.toLowerCase().includes(field.toLowerCase())
      )) {
        sanitized[key] = '[REDACTED]';
      }
    });

    return sanitized;
  }

  static log(level, message, data = {}) {
    const sanitizedData = this.sanitizeLogData(data);
    console[level](`[${new Date().toISOString()}] ${message}`, sanitizedData);
  }
}
```

## ğŸŒ í”„ë¡ íŠ¸ì—”ë“œ ë³´ì•ˆ

### CSP (Content Security Policy) ì„¤ì •
```html
<!-- index.htmlì— CSP í—¤ë” ì„¤ì • -->
<meta http-equiv="Content-Security-Policy" content="
  default-src 'self';
  script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net;
  style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
  font-src 'self' https://fonts.gstatic.com;
  img-src 'self' data: https:;
  connect-src 'self' https://api.yourservice.com;
  object-src 'none';
  base-uri 'self';
  form-action 'self';
">
```

### XSS ë°©ì§€
```javascript
// Reactì—ì„œ dangerouslySetInnerHTML ì•ˆì „í•˜ê²Œ ì‚¬ìš©
import DOMPurify from 'dompurify';

const SafeHtmlContent = ({ htmlContent }) => {
  const sanitizedHtml = useMemo(() => {
    return DOMPurify.sanitize(htmlContent, {
      ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u'],
      ALLOWED_ATTR: []
    });
  }, [htmlContent]);

  return (
    <div
      dangerouslySetInnerHTML={{ __html: sanitizedHtml }}
    />
  );
};

// URL íŒŒë¼ë¯¸í„° ê²€ì¦
function useSafeUrlParams() {
  const params = useParams();

  const safeParams = useMemo(() => {
    const safe = {};

    Object.keys(params).forEach(key => {
      // URL íŒŒë¼ë¯¸í„° ìƒˆë‹ˆíƒ€ì´ì§•
      safe[key] = InputValidator.sanitizeHtml(params[key] || '');
    });

    return safe;
  }, [params]);

  return safeParams;
}
```

### CSRF ë°©ì§€
```javascript
// CSRF í† í° ê´€ë¦¬
class CSRFProtection {
  static async getCSRFToken() {
    try {
      const response = await fetch('/api/csrf-token', {
        credentials: 'include'
      });
      const data = await response.json();
      return data.csrfToken;
    } catch (error) {
      console.error('CSRF í† í° íšë“ ì‹¤íŒ¨:', error);
      return null;
    }
  }

  static async makeSecureRequest(url, options = {}) {
    const csrfToken = await this.getCSRFToken();

    return fetch(url, {
      ...options,
      credentials: 'include',
      headers: {
        ...options.headers,
        'X-CSRF-Token': csrfToken,
        'Content-Type': 'application/json'
      }
    });
  }
}

// ì•ˆì „í•œ API í´ë¼ì´ì–¸íŠ¸
class SecureApiClient {
  constructor() {
    this.baseUrl = process.env.REACT_APP_API_URL;
  }

  async request(endpoint, options = {}) {
    const url = `${this.baseUrl}${endpoint}`;

    // CSRF ë³´í˜¸ ë° ì¸ì¦ í† í° ì¶”ê°€
    const secureOptions = {
      ...options,
      credentials: 'include',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${AuthService.getToken()}`,
        ...options.headers
      }
    };

    try {
      const response = await CSRFProtection.makeSecureRequest(url, secureOptions);

      if (!response.ok) {
        if (response.status === 401) {
          // í† í° ê°±ì‹  ì‹œë„
          await AuthService.refreshAccessToken();
          // ì¬ì‹œë„
          return this.request(endpoint, options);
        }
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      SecureLogger.log('error', 'API ìš”ì²­ ì‹¤íŒ¨', {
        endpoint,
        error: error.message
      });
      throw error;
    }
  }
}
```

## ğŸ“¡ API í†µì‹  ë³´ì•ˆ

### HTTPS ê°•ì œ ì‚¬ìš©
```javascript
// HTTPS ë¦¬ë‹¤ì´ë ‰ì…˜ í™•ì¸
function enforceHTTPS() {
  if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
    location.replace('https:' + window.location.href.substring(window.location.protocol.length));
  }
}

// ê°œë°œ í™˜ê²½ì—ì„œë§Œ HTTP í—ˆìš©
const API_BASE_URL = process.env.NODE_ENV === 'production'
  ? 'https://api.yourservice.com'
  : process.env.REACT_APP_API_URL;
```

### ìš”ì²­ ë¬´ê²°ì„± ê²€ì¦
```javascript
// API ìš”ì²­ ì„œëª… (ì„ íƒì  ë³´ì•ˆ ê°•í™”)
class RequestSigner {
  static async signRequest(data, secretKey) {
    const encoder = new TextEncoder();
    const keyData = encoder.encode(secretKey);
    const dataString = JSON.stringify(data);
    const dataBuffer = encoder.encode(dataString);

    const cryptoKey = await crypto.subtle.importKey(
      'raw',
      keyData,
      { name: 'HMAC', hash: 'SHA-256' },
      false,
      ['sign']
    );

    const signature = await crypto.subtle.sign('HMAC', cryptoKey, dataBuffer);
    return Array.from(new Uint8Array(signature))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }

  static async makeSignedRequest(url, data) {
    const timestamp = Date.now();
    const nonce = crypto.getRandomValues(new Uint32Array(1))[0].toString(16);

    const requestData = {
      ...data,
      timestamp,
      nonce
    };

    const signature = await this.signRequest(requestData, process.env.REACT_APP_API_SECRET);

    return fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Signature': signature,
        'X-Timestamp': timestamp.toString(),
        'X-Nonce': nonce
      },
      body: JSON.stringify(requestData)
    });
  }
}
```

## ğŸ“¦ ì˜ì¡´ì„± ê´€ë¦¬

### ì·¨ì•½ì  ìŠ¤ìº” ë° ê´€ë¦¬
```bash
# ì •ê¸°ì ì¸ ë³´ì•ˆ ê°ì‚¬
npm audit
npm audit fix

# ê³ ìœ„í—˜ ì·¨ì•½ì  í™•ì¸
npm audit --audit-level high

# package-lock.json ë³´ì•ˆ
npm ci  # npm install ëŒ€ì‹  ì‚¬ìš© (ë” ì•ˆì „)
```

### ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” íŒ¨í‚¤ì§€ ì‚¬ìš©
```javascript
// package.jsonì—ì„œ íŒ¨í‚¤ì§€ ê²€ì¦
{
  "dependencies": {
    "react": "^18.2.0",        // ë©”ì´ì € ë²„ì „ë§Œ ì—…ë°ì´íŠ¸
    "lodash": "~4.17.21"       // íŒ¨ì¹˜ ë²„ì „ë§Œ ì—…ë°ì´íŠ¸
  },
  "resolutions": {
    "minimist": "^1.2.6"       // ì·¨ì•½í•œ í•˜ìœ„ ì˜ì¡´ì„± ê°•ì œ ì—…ë°ì´íŠ¸
  }
}

// ëŸ°íƒ€ì„ ì˜ì¡´ì„± ê²€ì¦
class DependencyValidator {
  static validatePackage(packageName, expectedVersion) {
    try {
      const packageJson = require(`${packageName}/package.json`);
      const actualVersion = packageJson.version;

      if (!this.isVersionCompatible(actualVersion, expectedVersion)) {
        throw new Error(`ë³´ì•ˆ ìœ„í—˜: ${packageName} ë²„ì „ ë¶ˆì¼ì¹˜`);
      }

      return true;
    } catch (error) {
      SecureLogger.log('warn', 'íŒ¨í‚¤ì§€ ê²€ì¦ ì‹¤íŒ¨', {
        packageName,
        expectedVersion,
        error: error.message
      });
      return false;
    }
  }

  static isVersionCompatible(actual, expected) {
    // ê°„ë‹¨í•œ ë²„ì „ í˜¸í™˜ì„± ê²€ì‚¬
    return actual.startsWith(expected.replace(/[~^]/, ''));
  }
}
```

## ğŸ§ª ë³´ì•ˆ í…ŒìŠ¤íŠ¸

### ìë™í™”ëœ ë³´ì•ˆ í…ŒìŠ¤íŠ¸
```javascript
// Jestë¥¼ ì´ìš©í•œ ë³´ì•ˆ í…ŒìŠ¤íŠ¸
describe('ë³´ì•ˆ í…ŒìŠ¤íŠ¸', () => {
  describe('ì…ë ¥ ê²€ì¦', () => {
    test('XSS ê³µê²© ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì°¨ë‹¨í•´ì•¼ í•¨', () => {
      const maliciousInput = '<script>alert("XSS")</script>';
      const sanitized = InputValidator.sanitizeHtml(maliciousInput);

      expect(sanitized).not.toContain('<script>');
      expect(sanitized).not.toContain('alert');
    });

    test('SQL ì¸ì ì…˜ íŒ¨í„´ì„ ì œê±°í•´ì•¼ í•¨', () => {
      const maliciousQuery = "'; DROP TABLE users; --";
      const sanitized = InputValidator.validateSearchQuery(maliciousQuery);

      expect(sanitized).not.toContain('DROP');
      expect(sanitized).not.toContain('--');
    });

    test('í…œí”Œë¦¿ ë‚´ìš© ê¸¸ì´ ì œí•œì„ í™•ì¸í•´ì•¼ í•¨', () => {
      const longContent = 'a'.repeat(2001);

      expect(() => {
        InputValidator.validateTemplateContent(longContent);
      }).toThrow('í…œí”Œë¦¿ ë‚´ìš©ì´ ë„ˆë¬´ ê¹ë‹ˆë‹¤');
    });
  });

  describe('ì¸ì¦', () => {
    test('ë§Œë£Œëœ í† í°ì„ ê±°ë¶€í•´ì•¼ í•¨', () => {
      const expiredToken = generateExpiredToken();

      expect(AuthService.validateToken(expiredToken)).toBe(false);
    });

    test('ì˜ëª»ëœ í˜•ì‹ì˜ í† í°ì„ ê±°ë¶€í•´ì•¼ í•¨', () => {
      const invalidToken = 'invalid.token.format';

      expect(AuthService.validateToken(invalidToken)).toBe(false);
    });
  });

  describe('ê¶Œí•œ', () => {
    test('ê¶Œí•œì´ ì—†ëŠ” ì‚¬ìš©ìì˜ ì ‘ê·¼ì„ ì°¨ë‹¨í•´ì•¼ í•¨', () => {
      const user = { role: 'user' };
      const hasPermission = checkPermission(user, PERMISSIONS.TEMPLATE_APPROVE);

      expect(hasPermission).toBe(false);
    });
  });
});

// ë³´ì•ˆ í†µí•© í…ŒìŠ¤íŠ¸
describe('ë³´ì•ˆ í†µí•© í…ŒìŠ¤íŠ¸', () => {
  test('ë³´í˜¸ëœ ë¼ìš°íŠ¸ ì ‘ê·¼ í…ŒìŠ¤íŠ¸', async () => {
    render(<App />);

    // ë¡œê·¸ì¸í•˜ì§€ ì•Šì€ ìƒíƒœì—ì„œ ë³´í˜¸ëœ í˜ì´ì§€ ì ‘ê·¼
    fireEvent.click(screen.getByText('ëŒ€ì‹œë³´ë“œ'));

    // ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸ë˜ì–´ì•¼ í•¨
    await waitFor(() => {
      expect(screen.getByText('ë¡œê·¸ì¸')).toBeInTheDocument();
    });
  });
});
```

### ì¹¨íˆ¬ í…ŒìŠ¤íŠ¸ ì²´í¬ë¦¬ìŠ¤íŠ¸
```markdown
## ìˆ˜ë™ ë³´ì•ˆ í…ŒìŠ¤íŠ¸

### ì¸ì¦ ìš°íšŒ ì‹œë„
- [ ] í† í° ì—†ì´ ë³´í˜¸ëœ API ì ‘ê·¼
- [ ] ë§Œë£Œëœ í† í°ìœ¼ë¡œ ì ‘ê·¼
- [ ] ë‹¤ë¥¸ ì‚¬ìš©ìì˜ í† í° ì‚¬ìš©
- [ ] ë¡œê·¸ì•„ì›ƒ í›„ í† í° ì¬ì‚¬ìš©

### ê¶Œí•œ ì—ìŠ¤ì»¬ë ˆì´ì…˜
- [ ] URL ì§ì ‘ ì ‘ê·¼ìœ¼ë¡œ ê¶Œí•œ ìš°íšŒ
- [ ] API ìš”ì²­ì—ì„œ role íŒŒë¼ë¯¸í„° ì¡°ì‘
- [ ] ë‹¤ë¥¸ ì‚¬ìš©ìì˜ ë°ì´í„° ì ‘ê·¼

### ì…ë ¥ ê²€ì¦ ìš°íšŒ
- [ ] XSS ìŠ¤í¬ë¦½íŠ¸ ì‚½ì…
- [ ] SQL ì¸ì ì…˜ ì‹œë„
- [ ] íŒŒì¼ ì—…ë¡œë“œ ê²€ì¦ ìš°íšŒ
- [ ] íŒŒë¼ë¯¸í„° ì˜¤ì—¼ ê³µê²©

### ì„¸ì…˜ ê´€ë¦¬
- [ ] ì„¸ì…˜ ê³ ì • ê³µê²©
- [ ] ì„¸ì…˜ í•˜ì´ì¬í‚¹
- [ ] ë™ì‹œ ë¡œê·¸ì¸ ì²˜ë¦¬
- [ ] ìë™ ë¡œê·¸ì•„ì›ƒ í™•ì¸
```

## ğŸš¨ ì¸ì‹œë˜íŠ¸ ëŒ€ì‘

### ë³´ì•ˆ ì‚¬ê³  ëŒ€ì‘ ì ˆì°¨
```javascript
// ë³´ì•ˆ ì‚¬ê³  ê°ì§€ ë° ëŒ€ì‘
class SecurityIncidentManager {
  static INCIDENT_TYPES = {
    UNAUTHORIZED_ACCESS: 'unauthorized_access',
    DATA_BREACH: 'data_breach',
    XSS_ATTACK: 'xss_attack',
    BRUTE_FORCE: 'brute_force'
  };

  static detectSuspiciousActivity(activity) {
    const suspiciousPatterns = [
      {
        pattern: /admin|root|system/i,
        type: this.INCIDENT_TYPES.UNAUTHORIZED_ACCESS
      },
      {
        pattern: /<script|javascript:|vbscript:/i,
        type: this.INCIDENT_TYPES.XSS_ATTACK
      }
    ];

    for (const { pattern, type } of suspiciousPatterns) {
      if (pattern.test(activity.data)) {
        this.reportIncident(type, activity);
        return true;
      }
    }

    return false;
  }

  static reportIncident(type, details) {
    const incident = {
      id: crypto.randomUUID(),
      type,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: window.location.href,
      details: this.sanitizeIncidentData(details)
    };

    // ì¦‰ì‹œ ì„œë²„ì— ë³´ê³ 
    fetch('/api/security/incidents', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(incident)
    }).catch(console.error);

    // ë¡œì»¬ ë¡œê¹…
    SecureLogger.log('error', `ë³´ì•ˆ ì‚¬ê³  ê°ì§€: ${type}`, incident);

    // ì‹¬ê°í•œ ì‚¬ê³ ì˜ ê²½ìš° ì¦‰ì‹œ ë¡œê·¸ì•„ì›ƒ
    if (type === this.INCIDENT_TYPES.DATA_BREACH) {
      AuthService.logout();
      window.location.href = '/login?reason=security';
    }
  }

  static sanitizeIncidentData(data) {
    // ë¯¼ê°í•œ ì •ë³´ ì œê±°
    return SecureLogger.sanitizeLogData(data);
  }
}

// ì‹¤ì‹œê°„ ë³´ì•ˆ ëª¨ë‹ˆí„°ë§
class SecurityMonitor {
  constructor() {
    this.failedLoginAttempts = 0;
    this.lastFailedLogin = null;
    this.isMonitoring = true;
  }

  startMonitoring() {
    // ì˜ì‹¬ìŠ¤ëŸ¬ìš´ í™œë™ ëª¨ë‹ˆí„°ë§
    window.addEventListener('error', (event) => {
      if (this.isSuspiciousError(event.error)) {
        SecurityIncidentManager.reportIncident(
          SecurityIncidentManager.INCIDENT_TYPES.XSS_ATTACK,
          { error: event.error.message }
        );
      }
    });

    // ë¹„ì •ìƒì ì¸ ë„¤íŠ¸ì›Œí¬ ìš”ì²­ ëª¨ë‹ˆí„°ë§
    this.monitorNetworkRequests();
  }

  monitorNetworkRequests() {
    const originalFetch = window.fetch;
    window.fetch = async (...args) => {
      const response = await originalFetch(...args);

      if (response.status === 401) {
        this.handleUnauthorizedAccess();
      }

      return response;
    };
  }

  handleUnauthorizedAccess() {
    this.failedLoginAttempts++;
    this.lastFailedLogin = Date.now();

    // ì—°ì† ì‹¤íŒ¨ ì‹œ ê³„ì • ë³´í˜¸
    if (this.failedLoginAttempts >= 5) {
      SecurityIncidentManager.reportIncident(
        SecurityIncidentManager.INCIDENT_TYPES.BRUTE_FORCE,
        { attempts: this.failedLoginAttempts }
      );

      // ì¼ì‹œì  ì ‘ê·¼ ì°¨ë‹¨
      this.blockAccess(15 * 60 * 1000); // 15ë¶„
    }
  }

  blockAccess(duration) {
    localStorage.setItem('accessBlocked', Date.now() + duration);
    window.location.href = '/blocked';
  }

  isSuspiciousError(error) {
    const suspiciousMessages = [
      'script error',
      'permission denied',
      'access denied',
      'unauthorized'
    ];

    return suspiciousMessages.some(msg =>
      error.message.toLowerCase().includes(msg)
    );
  }
}
```

## âœ… ë³´ì•ˆ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ê°œë°œ ë‹¨ê³„
- [ ] **ì…ë ¥ ê²€ì¦**: ëª¨ë“  ì‚¬ìš©ì ì…ë ¥ ê²€ì¦ ë° ìƒˆë‹ˆíƒ€ì´ì§•
- [ ] **ì¶œë ¥ ì¸ì½”ë”©**: XSS ë°©ì§€ë¥¼ ìœ„í•œ ì ì ˆí•œ ì¸ì½”ë”©
- [ ] **ì¸ì¦ êµ¬í˜„**: ê°•ë ¥í•œ ì¸ì¦ ë©”ì»¤ë‹ˆì¦˜ êµ¬í˜„
- [ ] **ê¶Œí•œ ì œì–´**: ìµœì†Œ ê¶Œí•œ ì›ì¹™ ì ìš©
- [ ] **ì„¸ì…˜ ê´€ë¦¬**: ì•ˆì „í•œ ì„¸ì…˜ ì²˜ë¦¬
- [ ] **HTTPS ì‚¬ìš©**: ëª¨ë“  í†µì‹ ì— HTTPS ì ìš©
- [ ] **CSP ì„¤ì •**: Content Security Policy êµ¬ì„±
- [ ] **ì˜ì¡´ì„± ê²€ì‚¬**: ì·¨ì•½í•œ íŒ¨í‚¤ì§€ í™•ì¸ ë° ì—…ë°ì´íŠ¸

### í…ŒìŠ¤íŠ¸ ë‹¨ê³„
- [ ] **ìë™í™”ëœ ë³´ì•ˆ í…ŒìŠ¤íŠ¸**: ë‹¨ìœ„/í†µí•© í…ŒìŠ¤íŠ¸ì— ë³´ì•ˆ ê²€ì¦ í¬í•¨
- [ ] **ì¹¨íˆ¬ í…ŒìŠ¤íŠ¸**: ìˆ˜ë™ ë³´ì•ˆ í…ŒìŠ¤íŠ¸ ìˆ˜í–‰
- [ ] **ì½”ë“œ ê°ì‚¬**: ì •ì  ì½”ë“œ ë¶„ì„ ë„êµ¬ ì‚¬ìš©
- [ ] **ì˜ì¡´ì„± ê°ì‚¬**: npm audit ë“±ìœ¼ë¡œ ì·¨ì•½ì  ìŠ¤ìº”

### ë°°í¬ ë‹¨ê³„
- [ ] **í™˜ê²½ ë³€ìˆ˜ ë³´ì•ˆ**: ë¯¼ê°í•œ ì •ë³´ë¥¼ í™˜ê²½ ë³€ìˆ˜ë¡œ ê´€ë¦¬
- [ ] **ë¡œê¹… ì„¤ì •**: ë³´ì•ˆ ê´€ë ¨ ì´ë²¤íŠ¸ ë¡œê¹…
- [ ] **ëª¨ë‹ˆí„°ë§ êµ¬ì„±**: ì‹¤ì‹œê°„ ë³´ì•ˆ ëª¨ë‹ˆí„°ë§ ì„¤ì •
- [ ] **ë°±ì—… ë° ë³µêµ¬**: ë³´ì•ˆ ì‚¬ê³  ëŒ€ì‘ ê³„íš ìˆ˜ë¦½

### ìš´ì˜ ë‹¨ê³„
- [ ] **ì •ê¸° ê°ì‚¬**: ì£¼ê¸°ì ì¸ ë³´ì•ˆ ì ê²€
- [ ] **ì·¨ì•½ì  ê´€ë¦¬**: ìƒˆë¡œìš´ ì·¨ì•½ì  ëª¨ë‹ˆí„°ë§ ë° íŒ¨ì¹˜
- [ ] **ì‚¬ê³  ëŒ€ì‘**: ë³´ì•ˆ ì‚¬ê³  ëŒ€ì‘ ì ˆì°¨ ì ê²€
- [ ] **êµìœ¡ ë° í›ˆë ¨**: íŒ€ì› ë³´ì•ˆ êµìœ¡

---

## ğŸ“š ë³´ì•ˆ ë¦¬ì†ŒìŠ¤

### ì°¸ê³  ë¬¸ì„œ
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [React Security Best Practices](https://react.dev/learn/javascript-in-jsx-with-curly-braces#using-double-curlies-css-and-other-objects)
- [Web Security Guidelines](https://web.dev/security/)

### ë³´ì•ˆ ë„êµ¬
- **ESLint Security Plugin**: eslint-plugin-security
- **Dependency Scanner**: npm audit, Snyk
- **Static Analysis**: SonarQube, CodeQL
- **Runtime Protection**: Content Security Policy

### ë³´ì•ˆ ì»¤ë®¤ë‹ˆí‹°
- [í•œêµ­ì¸í„°ë„·ì§„í¥ì›(KISA)](https://www.kisa.or.kr/)
- [OWASP Korea](https://owasp.org/www-chapter-korea/)
- [ë³´ì•ˆë‰´ìŠ¤](https://www.boannews.com/)

---

*ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: 2024-09*
*ë¬¸ì„œ ë‹´ë‹¹: Security Team*