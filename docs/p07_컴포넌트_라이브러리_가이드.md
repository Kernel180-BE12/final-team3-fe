# p07_컴포넌트_라이브러리_가이드

## 🧩 재사용 가능한 컴포넌트 라이브러리 가이드

**AI 알림톡 생성기**에서 사용되는 모든 재사용 가능한 컴포넌트들의 사용법, Props 정의, 디자인 패턴을 정리한 종합 가이드입니다. 새로운 개발자가 빠르게 프로젝트에 기여할 수 있도록 돕고, 일관된 UI/UX를 유지하기 위한 표준을 제시합니다.

---

## 📋 컴포넌트 라이브러리 개요

### 설계 원칙

| 원칙 | 설명 | 예시 |
|------|------|------|
| **Single Responsibility** | 각 컴포넌트는 하나의 명확한 역할만 수행 | `BackButton`은 오직 뒤로가기 기능만 |
| **Composability** | 작은 컴포넌트들을 조합하여 복잡한 UI 구성 | `PricingCard` + `PricingCards` = 가격 정책 페이지 |
| **Reusability** | 다양한 컨텍스트에서 재사용 가능 | `ChatMessage`는 여러 채팅 화면에서 사용 |
| **Accessibility** | WCAG 2.1 가이드라인 준수 | 키보드 네비게이션, 스크린 리더 지원 |
| **Consistency** | 일관된 디자인 시스템 적용 | Tailwind CSS 기반 통일된 스타일링 |

### 컴포넌트 분류

```
src/components/
├── 📁 layout/          # 레이아웃 관련 컴포넌트
├── 📁 generator/       # 템플릿 생성 관련 컴포넌트
├── 📁 pricing/         # 가격 정책 관련 컴포넌트
├── 📁 statistics/      # 통계 및 차트 컴포넌트
├── 📁 settings/        # 설정 페이지 컴포넌트
├── 📁 chat/           # 채팅 기록 관련 컴포넌트
├── 📁 help/           # 도움말 컴포넌트
├── 📁 customization/  # 커스터마이징 컴포넌트
└── 📄 기본 컴포넌트들  # Header, Footer, ProtectedRoute 등
```

---

## 🔧 기본 컴포넌트들

### 1. BackButton - 뒤로가기 버튼

범용적으로 사용할 수 있는 뒤로가기 버튼 컴포넌트입니다.

#### Props
```typescript
interface BackButtonProps {
  className?: string;          // 추가 CSS 클래스 (선택)
  onClick?: () => void;        // 커스텀 클릭 핸들러 (선택)
  children?: React.ReactNode;  // 커스텀 텍스트 (선택, 기본값: "뒤로가기")
}
```

#### 사용 예시
```jsx
import BackButton from '@/components/pricing/BackButton';

// 기본 사용법
<BackButton />

// 커스텀 스타일링
<BackButton className="mb-4" />

// 커스텀 클릭 핸들러
<BackButton onClick={() => navigate('/dashboard')} />

// 커스텀 텍스트
<BackButton>이전 단계로</BackButton>
```

#### 시각적 사양
- **크기**: 자동 크기 조정 (내용에 따라)
- **색상**: 기본 gray-600, 호버 시 gray-900
- **아이콘**: 왼쪽 화살표 (Heroicons 스타일)
- **전환**: 200ms 색상 전환 애니메이션

#### 접근성
- 키보드 네비게이션 지원 (Tab, Enter)
- 스크린 리더를 위한 aria-label 자동 설정
- 포커스 표시 (outline)

#### 디자인 토큰
```css
.back-button {
  color: #4B5563;        /* text-gray-600 */
  transition: color 200ms ease;
}

.back-button:hover {
  color: #111827;        /* text-gray-900 */
}
```

---

## 💰 가격 정책 컴포넌트

### 2. PricingCard - 가격 플랜 카드

개별 가격 플랜을 표시하는 카드 컴포넌트입니다.

#### Props
```typescript
interface PricingCardProps {
  plan: {
    id: string;                    // 플랜 고유 ID ('free', 'pro', 'max')
    displayName: string;           // 표시될 플랜 이름
    description: string;           // 플랜 설명
    priceText: string;            // 가격 텍스트 (예: "₩29,900")
    billing?: string;             // 청구 주기 (예: "월 단위 결제")
    color: string;                // 색상 테마 키
    badge?: string;               // 배지 텍스트 (예: "인기")
    features: PlanFeature[];      // 기능 목록
    highlights?: string[];        // 추가 하이라이트
  };
  currentPlan: string;            // 현재 사용자의 플랜 ID
  onUpgrade?: (planId: string) => void;  // 업그레이드 클릭 핸들러
  featured?: boolean;             // 추천 플랜 여부 (기본값: false)
}

interface PlanFeature {
  name: string;                   // 기능 이름
  included: boolean;              // 포함 여부
  value?: string;                 // 수량 정보 (예: "월 100개")
}
```

#### 사용 예시
```jsx
import PricingCard from '@/components/pricing/PricingCard';

const planData = {
  id: 'pro',
  displayName: 'Pro',
  description: '전문적인 템플릿 제작',
  priceText: '₩29,900',
  billing: '월 단위 결제',
  color: 'orange',
  badge: '인기',
  features: [
    { name: '월 템플릿 생성', included: true, value: '200개' },
    { name: 'AI 고급 기능', included: true },
    { name: '팀 협업', included: true, value: '5명' },
    { name: '우선 지원', included: true },
    { name: '무제한 저장', included: false }
  ],
  highlights: [
    '가장 인기 있는 플랜',
    '중소기업에 최적화',
    '30일 무료 체험'
  ]
};

<PricingCard
  plan={planData}
  currentPlan="free"
  onUpgrade={(planId) => handleUpgrade(planId)}
  featured={true}
/>
```

#### 상태별 버튼 동작
```jsx
// 현재 플랜인 경우
isCurrentPlan ? (
  <button disabled className="current-plan-button">
    현재 사용 중
  </button>
) : canUpgrade ? (
  <button onClick={() => onUpgrade(plan.id)} className="upgrade-button">
    업그레이드
  </button>
) : (
  <button disabled className="disabled-button">
    무료 플랜
  </button>
)
```

#### 색상 시스템
```javascript
// data/plans.js 에서 정의된 색상 팔레트
export const PLAN_COLORS = {
  blue: {
    bg: 'bg-blue-50',
    border: 'border-blue-200',
    text: 'text-blue-700',
    button: 'bg-blue-600 hover:bg-blue-700',
    badge: 'bg-blue-100 text-blue-800'
  },
  orange: {
    bg: 'bg-orange-50',
    border: 'border-orange-200',
    text: 'text-orange-700',
    button: 'bg-orange-600 hover:bg-orange-700',
    badge: 'bg-orange-100 text-orange-800'
  },
  purple: {
    bg: 'bg-purple-50',
    border: 'border-purple-200',
    text: 'text-purple-700',
    button: 'bg-purple-600 hover:bg-purple-700',
    badge: 'bg-purple-100 text-purple-800'
  }
};
```

#### 반응형 동작
- **모바일**: 카드가 세로로 스택
- **태블릿**: 2열 그리드
- **데스크톱**: 3열 그리드
- **호버 효과**: 그림자 증가, 약간의 스케일 업

### 3. PricingCards - 가격 플랜 컨테이너

여러 PricingCard를 그리드로 배치하는 컨테이너 컴포넌트입니다.

#### Props
```typescript
interface PricingCardsProps {
  plans: PlanData[];              // 플랜 데이터 배열
  currentPlan: string;            // 현재 플랜
  onUpgrade: (planId: string) => void;  // 업그레이드 핸들러
  featuredPlan?: string;          // 추천 플랜 ID (선택)
}
```

#### 사용 예시
```jsx
import PricingCards from '@/components/pricing/PricingCards';
import { PLANS } from '@/data/plans';

<PricingCards
  plans={PLANS}
  currentPlan={user.plan}
  onUpgrade={handlePlanUpgrade}
  featuredPlan="pro"
/>
```

---

## 💬 채팅 및 메시지 컴포넌트

### 4. ChatMessage - 채팅 메시지

다양한 타입의 채팅 메시지를 표시하는 컴포넌트입니다.

#### Props
```typescript
interface ChatMessageProps {
  message: {
    type: 'user' | 'ai' | 'error' | 'version';  // 메시지 타입
    text: string;                               // 메시지 내용
    versionData?: {                            // 버전 데이터 (type이 'version'일 때)
      templateId: string;
      // 기타 버전 관련 데이터
    };
  };
  onSelectVersion?: (versionData: any) => void;  // 버전 선택 핸들러
}
```

#### 메시지 타입별 스타일

##### 사용자 메시지 (type: "user")
```jsx
<div className="flex justify-end mb-6">
  <div className="max-w-[70%] bg-indigo-600 text-white rounded-2xl rounded-br-md px-4 py-3">
    <p className="text-sm leading-relaxed whitespace-pre-line text-white">
      {message.text}
    </p>
  </div>
</div>
```

##### AI 응답 (type: "ai")
```jsx
<div className="flex justify-start mb-6">
  <div className="max-w-[70%] bg-white border border-gray-200 rounded-2xl rounded-bl-md px-4 py-3 shadow-sm">
    <p className="text-sm leading-relaxed whitespace-pre-line text-gray-800">
      {message.text}
    </p>
  </div>
</div>
```

##### 에러 메시지 (type: "error")
```jsx
<div className="flex justify-start mb-6">
  <div className="max-w-[70%] bg-red-50 border border-red-200 rounded-2xl rounded-bl-md px-4 py-3 shadow-sm">
    <div className="flex items-start space-x-3">
      <svg className="w-5 h-5 text-red-500 mt-0.5 flex-shrink-0">
        {/* 에러 아이콘 */}
      </svg>
      <div>
        <p className="text-red-800 text-sm font-medium mb-1">오류가 발생했습니다</p>
        <p className="text-red-700 text-sm leading-relaxed">{message.text}</p>
        <p className="text-red-600 text-xs mt-2">다시 시도하거나 다른 방식으로 요청해보세요.</p>
      </div>
    </div>
  </div>
</div>
```

##### 버전 선택 (type: "version")
```jsx
<button
  onClick={() => onSelectVersion(message.versionData)}
  className="inline-flex items-center bg-gray-800 text-white px-4 py-2 rounded-full font-semibold hover:bg-gray-700 transition-colors duration-200 mb-3"
>
  <span className="mr-2">✨</span>
  버전 {message.versionData.templateId}
  <span className="ml-2">→</span>
</button>
```

#### 사용 예시
```jsx
import { ChatMessage, LoadingMessage } from '@/components/generator/ChatMessage';

// 기본 사용법
const messages = [
  { type: 'user', text: '카페 오픈 이벤트 템플릿을 만들어주세요' },
  { type: 'ai', text: '카페 오픈 이벤트를 위한 템플릿을 생성했습니다...' },
  { type: 'error', text: 'API 서버에 연결할 수 없습니다.' }
];

{messages.map((message, index) => (
  <ChatMessage
    key={index}
    message={message}
    onSelectVersion={handleVersionSelect}
  />
))}

// 로딩 상태 표시
{isLoading && <LoadingMessage />}
```

### 5. LoadingMessage - 로딩 메시지

AI가 응답을 생성하는 동안 표시되는 로딩 애니메이션입니다.

#### 특징
- **애니메이션**: 3개의 점이 순차적으로 바운스
- **텍스트**: "템플릿을 생성하고 있습니다..."
- **스타일**: AI 메시지와 동일한 스타일
- **지연**: 각 점은 0.1초씩 지연되어 바운스

#### 사용 예시
```jsx
import { LoadingMessage } from '@/components/generator/ChatMessage';

{isGenerating && <LoadingMessage />}
```

---

## 📊 통계 및 차트 컴포넌트

### 6. KPICards - 핵심 지표 카드

대시보드의 주요 KPI를 카드 형태로 표시하는 컴포넌트입니다.

#### Props
```typescript
interface KPICardsProps {
  data: {
    totalTemplates: number;      // 총 템플릿 수
    approvedTemplates: number;   // 승인된 템플릿 수
    pendingApproval: number;     // 승인 대기 수
    totalUsage: number;          // 총 사용량
  };
  loading?: boolean;             // 로딩 상태
}
```

#### 사용 예시
```jsx
import KPICards from '@/components/statistics/KPICards';

const kpiData = {
  totalTemplates: 156,
  approvedTemplates: 134,
  pendingApproval: 12,
  totalUsage: 2847
};

<KPICards data={kpiData} loading={false} />
```

#### 카드 구성 요소
- **제목**: 지표 이름
- **값**: 숫자 값 (천 단위 콤마 표시)
- **아이콘**: 각 지표에 맞는 아이콘
- **색상**: 지표별 브랜드 색상
- **로딩 상태**: 스켈레톤 UI

### 7. StatusDistributionChart - 상태 분포 차트

템플릿 상태별 분포를 도넛 차트로 표시하는 컴포넌트입니다.

#### Props
```typescript
interface StatusDistributionChartProps {
  data: {
    approved: number;    // 승인됨
    pending: number;     // 승인 대기
    rejected: number;    // 거부됨
    draft: number;       // 초안
  };
  className?: string;
}
```

#### 사용 예시
```jsx
import StatusDistributionChart from '@/components/statistics/StatusDistributionChart';

const statusData = {
  approved: 89,
  pending: 12,
  rejected: 5,
  draft: 23
};

<StatusDistributionChart data={statusData} />
```

### 8. ApprovalTrendChart - 승인 트렌드 차트

시간에 따른 템플릿 승인 트렌드를 라인 차트로 표시합니다.

#### Props
```typescript
interface ApprovalTrendChartProps {
  data: Array<{
    date: string;        // 날짜 (YYYY-MM-DD)
    approved: number;    // 승인 수
    rejected: number;    // 거부 수
  }>;
  period: '7d' | '30d' | '90d';  // 기간
}
```

---

## 🔧 레이아웃 컴포넌트

### 9. AppSidebar - 애플리케이션 사이드바

메인 네비게이션을 담당하는 사이드바 컴포넌트입니다.

#### 주요 기능
- **메뉴 관리**: 동적 메뉴 구성
- **채팅 기록**: 호버 시 채팅 기록 패널 표시
- **권한 제어**: 사용자 역할에 따른 메뉴 표시/숨김
- **활성 상태**: 현재 페이지 하이라이트

#### Props
```typescript
interface AppSidebarProps {
  isOpen: boolean;                    // 사이드바 열림/닫힘 상태
  onToggle: () => void;              // 토글 핸들러
  currentPath: string;               // 현재 경로
  userRole?: 'user' | 'admin';       // 사용자 역할
}
```

#### 메뉴 구조
```javascript
const DEFAULT_TOP_MENU = [
  {
    id: 'dashboard',
    label: '대시보드',
    icon: HomeIcon,
    path: '/dashboard'
  },
  {
    id: 'chat-history',
    label: '채팅 기록',
    icon: ClockIcon,
    hasPanel: true  // 호버 패널 있음
  },
  {
    id: 'templates-list',
    label: '템플릿 목록',
    icon: ListIcon,
    path: '/templates'
  },
  {
    id: 'generator',
    label: '템플릿 생성',
    icon: SparklesIcon,
    path: '/create'
  }
];
```

#### 채팅 기록 호버 패널
- **지연 시간**: 300ms 후 표시/숨김
- **위치**: 사이드바 우측
- **기능**: 검색, 삭제, 선택
- **최대 항목**: 10개

### 10. ProtectedRoute - 보호된 라우트

인증이 필요한 페이지에 대한 접근을 제어하는 컴포넌트입니다.

#### Props
```typescript
interface ProtectedRouteProps {
  children: React.ReactNode;          // 보호할 컴포넌트
  requiredRole?: 'user' | 'admin';    // 필요한 권한 (선택)
  redirectTo?: string;                // 리다이렉트 경로 (기본값: '/login')
}
```

#### 사용 예시
```jsx
import ProtectedRoute from '@/components/ProtectedRoute';

// 기본 인증 체크
<Route path="/dashboard" element={
  <ProtectedRoute>
    <DashboardPage />
  </ProtectedRoute>
} />

// 관리자 권한 필요
<Route path="/admin" element={
  <ProtectedRoute requiredRole="admin">
    <AdminPage />
  </ProtectedRoute>
} />
```

---

## 🎨 커스터마이징 컴포넌트

### 11. KakaoPreview - 카카오톡 미리보기

생성된 템플릿을 카카오톡 형태로 미리보기하는 컴포넌트입니다.

#### Props
```typescript
interface KakaoPreviewProps {
  template: {
    title: string;              // 템플릿 제목
    content: string;            // 템플릿 내용
    variables?: Array<{         // 변수 목록
      name: string;
      placeholder: string;
      value?: string;
    }>;
    buttons?: Array<{           // 버튼 목록
      text: string;
      type: 'web' | 'app' | 'phone';
      url?: string;
    }>;
  };
  onVariableChange?: (name: string, value: string) => void;  // 변수 변경 핸들러
  showControls?: boolean;       // 편집 컨트롤 표시 여부
}
```

#### 사용 예시
```jsx
import KakaoPreview from '@/components/customization/KakaoPreview';

const templateData = {
  title: "카페 오픈 이벤트",
  content: "🎉 {{카페명}} 오픈 기념!\n\n📍 위치: {{주소}}\n💰 할인: 20% OFF",
  variables: [
    { name: '카페명', placeholder: '{{카페명}}', value: '' },
    { name: '주소', placeholder: '{{주소}}', value: '' }
  ],
  buttons: [
    { text: '자세히 보기', type: 'web', url: 'https://example.com' }
  ]
};

<KakaoPreview
  template={templateData}
  onVariableChange={(name, value) => updateVariable(name, value)}
  showControls={true}
/>
```

#### 변수 치환 로직
```javascript
const replaceVariables = (content, variables) => {
  let result = content;
  variables.forEach(variable => {
    if (variable.value) {
      result = result.replace(
        new RegExp(escapeRegExp(variable.placeholder), 'g'),
        variable.value
      );
    }
  });
  return result;
};
```

---

## 📱 모달 및 오버레이 컴포넌트

### 12. HelpModal - 도움말 모달

도움말 콘텐츠를 표시하는 모달 컴포넌트입니다.

#### Props
```typescript
interface HelpModalProps {
  isOpen: boolean;                    // 모달 열림 상태
  onClose: () => void;               // 닫기 핸들러
  initialTab?: string;               // 초기 탭 (선택)
}
```

#### 사용 예시
```jsx
import HelpModal from '@/components/help/HelpModal';

const [isHelpOpen, setIsHelpOpen] = useState(false);

<HelpModal
  isOpen={isHelpOpen}
  onClose={() => setIsHelpOpen(false)}
  initialTab="content"
/>
```

#### 탭 구성
- **content**: 콘텐츠 가이드
- **images**: 이미지 가이드
- **audit**: 심사 가이드
- **infotalk**: 정보톡 가이드
- **whitelist**: 화이트리스트 가이드
- **blacklist**: 블랙리스트 가이드
- **public**: 공개 템플릿 가이드

---

## 🎯 접근성 및 사용성 가이드라인

### 키보드 네비게이션

#### 지원되는 키보드 단축키
```javascript
const KEYBOARD_SHORTCUTS = {
  'Tab': '다음 요소로 포커스 이동',
  'Shift+Tab': '이전 요소로 포커스 이동',
  'Enter': '버튼 활성화, 링크 클릭',
  'Space': '체크박스 토글, 버튼 활성화',
  'Escape': '모달 닫기, 드롭다운 닫기',
  'Arrow Keys': '메뉴 내 네비게이션'
};
```

#### 포커스 관리
```jsx
// 모달 열릴 때 포커스 트랩
useEffect(() => {
  if (isOpen) {
    const focusableElements = modal.current.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );

    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];

    firstElement?.focus();

    const trapFocus = (e) => {
      if (e.key === 'Tab') {
        if (e.shiftKey && document.activeElement === firstElement) {
          e.preventDefault();
          lastElement.focus();
        } else if (!e.shiftKey && document.activeElement === lastElement) {
          e.preventDefault();
          firstElement.focus();
        }
      }
    };

    document.addEventListener('keydown', trapFocus);
    return () => document.removeEventListener('keydown', trapFocus);
  }
}, [isOpen]);
```

### 스크린 리더 지원

#### ARIA 속성 사용
```jsx
// 버튼 상태 표시
<button
  aria-pressed={isActive}
  aria-label={`${isActive ? '활성화됨' : '비활성화됨'} - 템플릿 승인`}
>
  승인
</button>

// 로딩 상태 표시
<div
  role="status"
  aria-live="polite"
  aria-label="템플릿을 생성하는 중입니다"
>
  <LoadingMessage />
</div>

// 에러 메시지
<div
  role="alert"
  aria-live="assertive"
>
  오류가 발생했습니다
</div>
```

### 색상 및 대비

#### 색상 접근성 기준
```css
/* WCAG AA 기준 대비율 4.5:1 이상 */
.text-primary {
  color: #1F2937;    /* 대비율: 12.6:1 */
}

.text-secondary {
  color: #4B5563;    /* 대비율: 7.0:1 */
}

.text-muted {
  color: #6B7280;    /* 대비율: 5.4:1 */
}

/* 상태별 색상 */
.text-success {
  color: #065F46;    /* 대비율: 8.9:1 */
}

.text-error {
  color: #991B1B;    /* 대비율: 9.2:1 */
}

.text-warning {
  color: #92400E;    /* 대비율: 6.8:1 */
}
```

---

## 🔧 개발자 도구 및 디버깅

### Storybook 연동

#### 스토리 작성 예시
```javascript
// stories/PricingCard.stories.js
export default {
  title: 'Components/Pricing/PricingCard',
  component: PricingCard,
  argTypes: {
    featured: { control: 'boolean' },
    currentPlan: {
      control: 'select',
      options: ['free', 'pro', 'max']
    }
  }
};

const Template = (args) => <PricingCard {...args} />;

export const Free = Template.bind({});
Free.args = {
  plan: PLANS.find(p => p.id === 'free'),
  currentPlan: 'free',
  featured: false
};

export const Pro = Template.bind({});
Pro.args = {
  plan: PLANS.find(p => p.id === 'pro'),
  currentPlan: 'free',
  featured: true
};

export const CurrentPlan = Template.bind({});
CurrentPlan.args = {
  plan: PLANS.find(p => p.id === 'pro'),
  currentPlan: 'pro',
  featured: false
};
```

### 컴포넌트 테스팅

#### React Testing Library 예시
```javascript
// tests/components/PricingCard.test.jsx
import { render, screen, fireEvent } from '@testing-library/react';
import PricingCard from '@/components/pricing/PricingCard';

const mockPlan = {
  id: 'pro',
  displayName: 'Pro',
  description: '전문가용 플랜',
  priceText: '₩29,900',
  color: 'orange',
  features: [
    { name: '월 200개 템플릿', included: true, value: '200개' }
  ]
};

describe('PricingCard', () => {
  test('플랜 정보를 올바르게 표시한다', () => {
    render(
      <PricingCard
        plan={mockPlan}
        currentPlan="free"
        onUpgrade={jest.fn()}
      />
    );

    expect(screen.getByText('Pro')).toBeInTheDocument();
    expect(screen.getByText('₩29,900')).toBeInTheDocument();
    expect(screen.getByText('월 200개 템플릿 (200개)')).toBeInTheDocument();
  });

  test('업그레이드 버튼 클릭 시 핸들러가 호출된다', () => {
    const mockUpgrade = jest.fn();

    render(
      <PricingCard
        plan={mockPlan}
        currentPlan="free"
        onUpgrade={mockUpgrade}
      />
    );

    fireEvent.click(screen.getByText('업그레이드'));
    expect(mockUpgrade).toHaveBeenCalledWith('pro');
  });

  test('현재 플랜인 경우 올바른 상태를 표시한다', () => {
    render(
      <PricingCard
        plan={mockPlan}
        currentPlan="pro"
        onUpgrade={jest.fn()}
      />
    );

    expect(screen.getByText('현재 사용 중')).toBeInTheDocument();
    expect(screen.getByText('현재 플랜')).toBeInTheDocument();
  });
});
```

### Props 유효성 검증

#### PropTypes 사용 예시
```javascript
import PropTypes from 'prop-types';

PricingCard.propTypes = {
  plan: PropTypes.shape({
    id: PropTypes.string.isRequired,
    displayName: PropTypes.string.isRequired,
    description: PropTypes.string.isRequired,
    priceText: PropTypes.string.isRequired,
    billing: PropTypes.string,
    color: PropTypes.string.isRequired,
    badge: PropTypes.string,
    features: PropTypes.arrayOf(PropTypes.shape({
      name: PropTypes.string.isRequired,
      included: PropTypes.bool.isRequired,
      value: PropTypes.string
    })).isRequired,
    highlights: PropTypes.arrayOf(PropTypes.string)
  }).isRequired,
  currentPlan: PropTypes.string.isRequired,
  onUpgrade: PropTypes.func,
  featured: PropTypes.bool
};

PricingCard.defaultProps = {
  featured: false,
  onUpgrade: () => {}
};
```

---

## 📐 디자인 시스템 통합

### Tailwind CSS 커스텀 클래스

#### 컴포넌트별 유틸리티 클래스
```css
/* components.css */
@layer components {
  .pricing-card {
    @apply relative p-6 rounded-2xl border-2 transition-all duration-300 hover:shadow-lg;
  }

  .pricing-card-featured {
    @apply border-orange-300 shadow-lg scale-105;
  }

  .chat-message-user {
    @apply bg-indigo-600 text-white rounded-2xl rounded-br-md px-4 py-3;
  }

  .chat-message-ai {
    @apply bg-white border border-gray-200 rounded-2xl rounded-bl-md px-4 py-3 shadow-sm;
  }

  .back-button {
    @apply flex items-center space-x-2 text-gray-600 hover:text-gray-900 transition-colors duration-200;
  }
}
```

### 색상 팔레트

#### 브랜드 컬러 시스템
```javascript
// tailwind.config.js
module.exports = {
  theme: {
    extend: {
      colors: {
        brand: {
          50: '#EEF2FF',
          100: '#E0E7FF',
          500: '#6366F1',  // Primary
          600: '#4F46E5',  // Primary Dark
          700: '#4338CA'   // Primary Darker
        },
        success: {
          50: '#ECFDF5',
          500: '#10B981',
          700: '#047857'
        },
        warning: {
          50: '#FFFBEB',
          500: '#F59E0B',
          700: '#B45309'
        },
        error: {
          50: '#FEF2F2',
          500: '#EF4444',
          700: '#B91C1C'
        }
      }
    }
  }
}
```

---

## 🚀 성능 최적화 가이드라인

### 컴포넌트 최적화

#### React.memo 사용 기준
```jsx
// Props가 자주 변경되지 않는 컴포넌트
const PricingCard = React.memo(({ plan, currentPlan, onUpgrade, featured }) => {
  // 컴포넌트 구현
}, (prevProps, nextProps) => {
  // 얕은 비교로 불충분한 경우 커스텀 비교 함수
  return (
    prevProps.plan.id === nextProps.plan.id &&
    prevProps.currentPlan === nextProps.currentPlan &&
    prevProps.featured === nextProps.featured
  );
});

// Props가 자주 변경되는 컴포넌트는 memo 사용하지 않음
const ChatMessage = ({ message, onSelectVersion }) => {
  // 메모이제이션 없이 구현
};
```

#### useMemo와 useCallback 활용
```jsx
const ChatHistoryPanel = ({ isVisible, onSelectChat }) => {
  // 비싼 계산은 useMemo로 캐싱
  const filteredHistory = useMemo(() => {
    return chatHistory.filter(chat =>
      chat.title.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [chatHistory, searchTerm]);

  // 콜백 함수는 useCallback으로 안정화
  const handleSearchChange = useCallback((e) => {
    setSearchTerm(e.target.value);
  }, []);

  return (
    // 컴포넌트 JSX
  );
};
```

### 번들 크기 최적화

#### 조건부 임포트
```jsx
// 큰 라이브러리는 동적 임포트
const ChartComponent = lazy(() => import('./ChartComponent'));

// 조건부 렌더링과 함께 사용
{showChart && (
  <Suspense fallback={<div>차트 로딩 중...</div>}>
    <ChartComponent data={chartData} />
  </Suspense>
)}
```

#### 트리 셰이킹 최적화
```javascript
// ❌ 전체 라이브러리 임포트
import * as icons from 'heroicons/react/24/outline';

// ✅ 필요한 아이콘만 임포트
import { HomeIcon, SparklesIcon } from 'heroicons/react/24/outline';
```

---

## 📚 컴포넌트 문서화 자동화

### JSDoc 주석 작성

#### 표준 JSDoc 형식
```javascript
/**
 * 가격 플랜을 표시하는 카드 컴포넌트
 *
 * @component
 * @param {Object} props - 컴포넌트 props
 * @param {Object} props.plan - 플랜 데이터 객체
 * @param {string} props.plan.id - 플랜 고유 식별자
 * @param {string} props.plan.displayName - 화면에 표시될 플랜 이름
 * @param {string} props.currentPlan - 현재 사용자의 플랜 ID
 * @param {Function} [props.onUpgrade] - 업그레이드 버튼 클릭 핸들러
 * @param {boolean} [props.featured=false] - 추천 플랜 여부
 *
 * @example
 * ```jsx
 * <PricingCard
 *   plan={planData}
 *   currentPlan="free"
 *   onUpgrade={(planId) => handleUpgrade(planId)}
 *   featured={true}
 * />
 * ```
 *
 * @returns {JSX.Element} 가격 플랜 카드 컴포넌트
 */
const PricingCard = ({ plan, currentPlan, onUpgrade, featured = false }) => {
  // 컴포넌트 구현
};
```

### 자동 문서 생성

#### React Docgen 설정
```javascript
// docgen.config.js
module.exports = {
  components: 'src/components/**/*.jsx',
  output: 'docs/components.json',
  handlers: [
    require('react-docgen').defaultHandlers.propTypesHandler,
    require('react-docgen').defaultHandlers.propTypesCompositionHandler,
    require('react-docgen').defaultHandlers.propDocBlockHandler
  ]
};
```

---

## 🔮 향후 개선 계획

### 단기 계획 (1-2개월)

#### 1. 디자인 토큰 시스템 구축
```javascript
// design-tokens.js
export const tokens = {
  spacing: {
    xs: '0.5rem',
    sm: '1rem',
    md: '1.5rem',
    lg: '2rem',
    xl: '3rem'
  },
  typography: {
    body: {
      fontSize: '0.875rem',
      lineHeight: '1.5',
      fontWeight: '400'
    },
    heading: {
      fontSize: '1.5rem',
      lineHeight: '1.25',
      fontWeight: '600'
    }
  },
  colors: {
    // 브랜드 색상 시스템
  }
};
```

#### 2. 컴포넌트 Playground 구축
- 실시간 Props 편집
- 코드 스니펫 자동 생성
- 접근성 테스트 자동화

### 중기 계획 (3-6개월)

#### 1. 고급 애니메이션 시스템
```jsx
// Framer Motion 기반 애니메이션
const AnimatedCard = motion(PricingCard);

<AnimatedCard
  initial={{ opacity: 0, y: 20 }}
  animate={{ opacity: 1, y: 0 }}
  transition={{ duration: 0.3, delay: index * 0.1 }}
  whileHover={{ scale: 1.02 }}
/>
```

#### 2. 테마 시스템 구축
```jsx
// Theme Provider
<ThemeProvider theme={lightTheme}>
  <App />
</ThemeProvider>

// 컴포넌트에서 테마 사용
const StyledCard = styled.div`
  background: ${props => props.theme.colors.surface};
  color: ${props => props.theme.colors.onSurface};
`;
```

---

## 💡 모범 사례 및 팁

### 컴포넌트 네이밍

#### 일관된 네이밍 컨벤션
```
// ✅ 올바른 네이밍
PricingCard          // 명사 + 명사
ChatMessage          // 명사 + 명사
BackButton           // 형용사 + 명사
LoadingMessage       // 형용사 + 명사

// ❌ 잘못된 네이밍
GetPricing          // 동사로 시작
priceCard           // 소문자로 시작
Pricing_Card        // 언더스코어 사용
```

### Props 설계

#### Props 인터페이스 설계 원칙
```typescript
// ✅ 좋은 Props 설계
interface GoodProps {
  // 필수 props는 optional 없이
  data: UserData;

  // 선택적 props는 명확한 기본값
  size?: 'sm' | 'md' | 'lg';
  variant?: 'primary' | 'secondary';

  // 콜백은 명확한 파라미터
  onClick?: (event: MouseEvent) => void;
  onDataChange?: (newData: UserData) => void;

  // boolean props는 is/has/can 접두사
  isLoading?: boolean;
  hasError?: boolean;
  canEdit?: boolean;
}

// ❌ 나쁜 Props 설계
interface BadProps {
  data?: any;              // any 타입 사용
  config?: object;         // 모호한 객체
  callback?: Function;     // 타입 없는 함수
  flag?: boolean;          // 의미 불분명
}
```

### 에러 처리

#### 컴포넌트 레벨 에러 바운더리
```jsx
class ComponentErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.error('컴포넌트 에러:', error, errorInfo);

    // 에러 리포팅 서비스로 전송
    if (window.gtag) {
      window.gtag('event', 'exception', {
        description: error.toString(),
        fatal: false
      });
    }
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="p-4 bg-red-50 border border-red-200 rounded-lg">
          <p className="text-red-800">컴포넌트 로딩 중 오류가 발생했습니다.</p>
          <button
            onClick={() => this.setState({ hasError: false, error: null })}
            className="mt-2 px-3 py-1 bg-red-600 text-white rounded text-sm"
          >
            다시 시도
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

이 컴포넌트 라이브러리 가이드는 **AI 알림톡 생성기** 프로젝트의 모든 재사용 가능한 컴포넌트를 체계적으로 정리하여 개발 효율성을 높이고 일관된 사용자 경험을 제공하는 데 도움이 될 것입니다. 새로운 컴포넌트 개발 시에도 이 가이드의 원칙과 패턴을 따라 확장해 나가시기 바랍니다.