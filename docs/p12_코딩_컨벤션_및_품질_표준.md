# 코딩 컨벤션 및 품질 표준

## 📋 목차
1. [기본 원칙](#기본-원칙)
2. [네이밍 컨벤션](#네이밍-컨벤션)
3. [파일 구조 및 조직](#파일-구조-및-조직)
4. [JavaScript/React 스타일](#javascriptreact-스타일)
5. [CSS/Tailwind 스타일](#csstailwind-스타일)
6. [주석 및 문서화](#주석-및-문서화)
7. [ESLint 규칙](#eslint-규칙)
8. [코드 리뷰 체크리스트](#코드-리뷰-체크리스트)
9. [품질 검증 도구](#품질-검증-도구)

## 🎯 기본 원칙

### 코드 철학
1. **가독성 우선**: 코드는 컴퓨터보다 사람이 읽기 위해 작성됩니다
2. **일관성**: 팀원 모두가 동일한 스타일을 따릅니다
3. **단순성**: 복잡함보다는 단순하고 명확한 해결책을 선택합니다
4. **재사용성**: DRY 원칙을 따르며 모듈화를 추구합니다
5. **확장성**: 미래의 변경사항을 고려한 유연한 구조를 만듭니다

### 품질 지표
```javascript
// 좋은 코드의 특징
const QUALITY_METRICS = {
  readability: '타인이 5분 내에 이해할 수 있는가?',
  maintainability: '변경이 쉬운가?',
  testability: '테스트하기 쉬운가?',
  performance: '성능에 문제가 없는가?',
  security: '보안 취약점이 없는가?'
};
```

## 📝 네이밍 컨벤션

### 변수 및 함수
```javascript
// ✅ 좋은 예
const userTemplateCount = 42;
const isAuthenticated = true;
const templateCategories = ['business', 'marketing'];

function getUserTemplates(userId) {
  return templates.filter(template => template.userId === userId);
}

const handleSubmitTemplate = async (templateData) => {
  // 비동기 작업 처리
};

// ❌ 나쁜 예
const cnt = 42;
const flag = true;
const arr = ['business', 'marketing'];

function get(id) {
  return templates.filter(t => t.uid === id);
}
```

### 컴포넌트 및 클래스
```javascript
// ✅ PascalCase 사용
const TemplateCard = ({ template }) => {
  return <div className="template-card">{template.title}</div>;
};

class ApiService {
  constructor() {
    this.baseUrl = process.env.REACT_APP_API_URL;
  }
}

// ❌ 잘못된 케이스
const templateCard = () => {};
const Template_Card = () => {};
class apiService {}
```

### 상수 및 환경변수
```javascript
// ✅ SCREAMING_SNAKE_CASE
const API_ENDPOINTS = {
  TEMPLATES: '/api/templates',
  USERS: '/api/users',
  STATISTICS: '/api/statistics'
};

const MAX_TEMPLATE_LENGTH = 1000;
const DEFAULT_PAGINATION_SIZE = 20;

// 환경변수
REACT_APP_API_URL=https://api.example.com
REACT_APP_SENTRY_DSN=https://...
```

### 파일 및 디렉토리
```
// ✅ kebab-case (파일)
template-card.jsx
user-dashboard.jsx
api-service.js

// ✅ PascalCase (컴포넌트 파일)
TemplateCard.jsx
UserDashboard.jsx
GeneratorPage.jsx

// ✅ camelCase (유틸리티, 훅)
useAuth.js
apiHelpers.js
jsonParser.js

// ✅ lowercase (디렉토리)
components/
pages/
hooks/
utils/
```

## 📁 파일 구조 및 조직

### 디렉토리 구조
```
src/
├── components/          # 재사용 컴포넌트
│   ├── common/         # 공통 UI 컴포넌트
│   │   ├── Button.jsx
│   │   ├── Modal.jsx
│   │   └── index.js    # 배럴 익스포트
│   ├── generator/      # 도메인별 컴포넌트
│   └── statistics/
├── pages/              # 페이지 컴포넌트
├── hooks/              # 커스텀 훅
├── utils/              # 유틸리티 함수
├── services/           # API 서비스
├── stores/             # 상태 관리
├── constants/          # 상수 정의
└── types/              # TypeScript 타입 정의
```

### 컴포넌트 파일 구조
```javascript
// TemplateCard.jsx
import React, { useState, useCallback } from 'react';
import PropTypes from 'prop-types';
import { formatDate } from '../utils/dateUtils';

// 상수는 컴포넌트 외부에 정의
const TEMPLATE_STATUS = {
  DRAFT: 'draft',
  PENDING: 'pending',
  APPROVED: 'approved'
};

// 메인 컴포넌트
const TemplateCard = ({
  template,
  onApprove,
  onReject,
  className = ''
}) => {
  // State
  const [isLoading, setIsLoading] = useState(false);

  // Callbacks
  const handleApprove = useCallback(async () => {
    setIsLoading(true);
    try {
      await onApprove(template.id);
    } catch (error) {
      console.error('승인 실패:', error);
    } finally {
      setIsLoading(false);
    }
  }, [template.id, onApprove]);

  // Derived state
  const isApproved = template.status === TEMPLATE_STATUS.APPROVED;
  const formattedDate = formatDate(template.createdAt);

  // Early returns
  if (!template) {
    return null;
  }

  // Main render
  return (
    <div className={`template-card ${className}`}>
      <h3 className="template-title">{template.title}</h3>
      <p className="template-date">{formattedDate}</p>

      {!isApproved && (
        <div className="template-actions">
          <button
            onClick={handleApprove}
            disabled={isLoading}
            className="btn-approve"
          >
            {isLoading ? '처리 중...' : '승인'}
          </button>
        </div>
      )}
    </div>
  );
};

// PropTypes
TemplateCard.propTypes = {
  template: PropTypes.shape({
    id: PropTypes.string.isRequired,
    title: PropTypes.string.isRequired,
    status: PropTypes.oneOf(Object.values(TEMPLATE_STATUS)).isRequired,
    createdAt: PropTypes.string.isRequired
  }).isRequired,
  onApprove: PropTypes.func.isRequired,
  onReject: PropTypes.func,
  className: PropTypes.string
};

export default TemplateCard;
```

### 배럴 익스포트 패턴
```javascript
// components/common/index.js
export { default as Button } from './Button';
export { default as Modal } from './Modal';
export { default as Input } from './Input';

// 사용법
import { Button, Modal, Input } from '../components/common';
```

## ⚛️ JavaScript/React 스타일

### 함수 정의
```javascript
// ✅ 화살표 함수 (컴포넌트, 유틸리티)
const UserCard = ({ user }) => {
  return <div>{user.name}</div>;
};

const calculateTotal = (items) => {
  return items.reduce((sum, item) => sum + item.price, 0);
};

// ✅ 일반 함수 (호이스팅이 필요한 경우)
function validateTemplate(template) {
  if (!template.title) {
    throw new Error('제목이 필요합니다');
  }
  return true;
}
```

### 조건부 렌더링
```javascript
// ✅ 권장 패턴
const TemplateList = ({ templates, isLoading }) => {
  // Early return
  if (isLoading) {
    return <LoadingSpinner />;
  }

  if (templates.length === 0) {
    return <EmptyState message="템플릿이 없습니다" />;
  }

  return (
    <div className="template-list">
      {templates.map(template => (
        <TemplateCard key={template.id} template={template} />
      ))}
    </div>
  );
};

// ❌ 복잡한 삼항 연산자 지양
return (
  <div>
    {isLoading ? (
      <LoadingSpinner />
    ) : templates.length === 0 ? (
      <EmptyState />
    ) : (
      templates.map(template => <TemplateCard key={template.id} />)
    )}
  </div>
);
```

### 이벤트 핸들링
```javascript
// ✅ 명확한 핸들러 네이밍
const TemplateForm = () => {
  const handleSubmit = (event) => {
    event.preventDefault();
    // 제출 로직
  };

  const handleInputChange = (event) => {
    const { name, value } = event.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleTemplateDelete = async (templateId) => {
    try {
      await deleteTemplate(templateId);
      // 성공 처리
    } catch (error) {
      // 에러 처리
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input name="title" onChange={handleInputChange} />
      <button type="submit">저장</button>
    </form>
  );
};
```

### 비동기 처리
```javascript
// ✅ async/await 사용
const useTemplates = () => {
  const [templates, setTemplates] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchTemplates = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const response = await apiService.getTemplates();
      setTemplates(response.data);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchTemplates();
  }, [fetchTemplates]);

  return { templates, loading, error, refetch: fetchTemplates };
};
```

### 상태 관리 패턴
```javascript
// ✅ Zustand 스토어 패턴
import { create } from 'zustand';

const useAuthStore = create((set, get) => ({
  // State
  user: null,
  isAuthenticated: false,
  loading: false,

  // Actions
  login: async (credentials) => {
    set({ loading: true });
    try {
      const user = await authService.login(credentials);
      set({ user, isAuthenticated: true, loading: false });
    } catch (error) {
      set({ loading: false });
      throw error;
    }
  },

  logout: () => {
    authService.logout();
    set({ user: null, isAuthenticated: false });
  },

  // Selectors
  getUserRole: () => get().user?.role || 'guest'
}));
```

## 🎨 CSS/Tailwind 스타일

### Tailwind 클래스 정렬
```javascript
// ✅ 논리적 그룹별 정렬
const Button = ({ children, variant = 'primary' }) => {
  return (
    <button
      className={`
        inline-flex items-center justify-center
        px-4 py-2
        text-sm font-medium
        border border-transparent rounded-md
        transition-colors duration-200
        hover:bg-opacity-80 focus:outline-none focus:ring-2
        disabled:opacity-50 disabled:cursor-not-allowed
        ${variant === 'primary'
          ? 'bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500'
          : 'bg-gray-200 text-gray-900 hover:bg-gray-300 focus:ring-gray-500'
        }
      `}
    >
      {children}
    </button>
  );
};
```

### 반응형 디자인
```javascript
// ✅ 모바일 우선 접근법
const ResponsiveCard = ({ children }) => {
  return (
    <div className="
      p-4
      bg-white
      rounded-lg
      shadow-sm
      sm:p-6
      md:p-8
      lg:max-w-4xl
      lg:mx-auto
    ">
      {children}
    </div>
  );
};
```

### 커스텀 CSS 클래스
```css
/* styles/components.css */
@layer components {
  .btn-primary {
    @apply inline-flex items-center px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500;
  }

  .card {
    @apply bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden;
  }

  .input-field {
    @apply block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500;
  }
}
```

## 📝 주석 및 문서화

### JSDoc 스타일
```javascript
/**
 * 템플릿 승인 상태를 업데이트합니다
 * @param {string} templateId - 템플릿 고유 ID
 * @param {('approved'|'rejected'|'pending')} status - 변경할 승인 상태
 * @param {string} [reason] - 거부 사유 (거부 시 필수)
 * @returns {Promise<Template>} 업데이트된 템플릿 객체
 * @throws {ValidationError} 잘못된 상태값이나 필수 파라미터 누락 시
 */
async function updateTemplateStatus(templateId, status, reason) {
  if (!templateId || !status) {
    throw new ValidationError('템플릿 ID와 상태는 필수입니다');
  }

  if (status === 'rejected' && !reason) {
    throw new ValidationError('거부 시 사유가 필요합니다');
  }

  // API 호출 로직
  const response = await apiService.updateTemplate(templateId, {
    status,
    reason,
    updatedAt: new Date().toISOString()
  });

  return response.data;
}
```

### 인라인 주석 가이드라인
```javascript
// ✅ 좋은 주석 - 의도를 설명
const UserDashboard = () => {
  // 사용자가 처음 방문할 때만 가이드 표시
  const [showGuide, setShowGuide] = useState(() => {
    return !localStorage.getItem('hasVisitedDashboard');
  });

  // 템플릿 목록을 페이지네이션으로 처리 (성능 최적화)
  const { data: templates, loading } = usePagination({
    fetcher: apiService.getTemplates,
    pageSize: 20
  });

  return (
    <div>
      {/* 가이드는 첫 방문 시에만 표시 */}
      {showGuide && <WelcomeGuide onClose={() => setShowGuide(false)} />}
      <TemplateList templates={templates} loading={loading} />
    </div>
  );
};

// ❌ 나쁜 주석 - 코드 자체를 그대로 설명
const badExample = () => {
  // showGuide를 false로 설정
  setShowGuide(false);

  // 템플릿 배열을 맵으로 순회
  templates.map(template => {
    // 템플릿 카드 컴포넌트 리턴
    return <TemplateCard template={template} />;
  });
};
```

### README 및 컴포넌트 문서
```markdown
# TemplateCard 컴포넌트

템플릿 정보를 카드 형태로 표시하는 컴포넌트입니다.

## Props

| Prop | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| template | Template | ✓ | - | 표시할 템플릿 객체 |
| onApprove | function | ✓ | - | 승인 버튼 클릭 핸들러 |
| onReject | function | - | - | 거부 버튼 클릭 핸들러 |
| className | string | - | '' | 추가 CSS 클래스 |

## 사용 예시

```jsx
<TemplateCard
  template={template}
  onApprove={(id) => handleApprove(id)}
  onReject={(id) => handleReject(id)}
  className="mb-4"
/>
```
```

## 🔧 ESLint 규칙

### .eslintrc.js 설정
```javascript
module.exports = {
  extends: [
    'eslint:recommended',
    '@eslint/js/recommended',
    'plugin:react/recommended',
    'plugin:react-hooks/recommended'
  ],
  plugins: ['react', 'react-hooks'],
  rules: {
    // JavaScript 규칙
    'no-console': 'warn',
    'no-debugger': 'error',
    'no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
    'prefer-const': 'error',
    'no-var': 'error',

    // React 규칙
    'react/prop-types': 'warn',
    'react/react-in-jsx-scope': 'off', // React 17+에서 불필요
    'react/jsx-uses-react': 'off',
    'react/jsx-uses-vars': 'error',
    'react/jsx-key': 'error',
    'react/no-array-index-key': 'warn',

    // React Hooks 규칙
    'react-hooks/rules-of-hooks': 'error',
    'react-hooks/exhaustive-deps': 'warn',

    // 커스텀 규칙
    'max-len': ['warn', { code: 100, ignoreUrls: true }],
    'object-curly-spacing': ['error', 'always'],
    'array-bracket-spacing': ['error', 'never'],
    'comma-dangle': ['error', 'never']
  },
  settings: {
    react: {
      version: 'detect'
    }
  }
};
```

## ✅ 코드 리뷰 체크리스트

### 기능성
- [ ] 요구사항을 정확히 구현했는가?
- [ ] 에지 케이스가 적절히 처리되었는가?
- [ ] 에러 핸들링이 포함되어 있는가?
- [ ] 접근성(a11y) 요구사항을 충족하는가?

### 코드 품질
- [ ] 함수/컴포넌트가 단일 책임을 갖는가?
- [ ] 네이밍이 명확하고 일관성 있는가?
- [ ] 불필요한 복잡성이 없는가?
- [ ] DRY 원칙을 따르는가?

### 성능
- [ ] 불필요한 리렌더링이 없는가?
- [ ] 메모이제이션이 적절히 사용되었는가?
- [ ] 번들 크기에 미치는 영향이 고려되었는가?
- [ ] 메모리 누수 가능성이 없는가?

### 보안
- [ ] 사용자 입력이 적절히 검증되는가?
- [ ] XSS 취약점이 없는가?
- [ ] 민감한 정보가 노출되지 않는가?
- [ ] HTTPS만 사용하는가?

### 테스트
- [ ] 단위 테스트가 작성되었는가?
- [ ] 테스트 커버리지가 충분한가?
- [ ] 통합 테스트가 필요한 경우 포함되었는가?

### 문서화
- [ ] JSDoc 주석이 적절히 작성되었는가?
- [ ] README나 컴포넌트 문서가 업데이트되었는가?
- [ ] 복잡한 로직에 주석이 포함되었는가?

## 🛠️ 품질 검증 도구

### pre-commit 훅 설정
```json
// package.json
{
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "lint-staged": {
    "src/**/*.{js,jsx}": [
      "eslint --fix",
      "prettier --write",
      "git add"
    ],
    "src/**/*.{css,scss}": [
      "stylelint --fix",
      "prettier --write",
      "git add"
    ]
  }
}
```

### VS Code 설정
```json
// .vscode/settings.json
{
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true,
    "source.organizeImports": true
  },
  "eslint.validate": [
    "javascript",
    "javascriptreact"
  ],
  "editor.rulers": [80, 100],
  "files.trimTrailingWhitespace": true,
  "files.insertFinalNewline": true
}
```

### 자동화된 품질 검사
```bash
# package.json scripts
{
  "scripts": {
    "lint": "eslint src/ --ext .js,.jsx",
    "lint:fix": "eslint src/ --ext .js,.jsx --fix",
    "format": "prettier --write \"src/**/*.{js,jsx,css,md}\"",
    "type-check": "tsc --noEmit",
    "quality": "npm run lint && npm run type-check && npm run test",
    "pre-push": "npm run quality"
  }
}
```

## 📊 품질 메트릭

### 코드 복잡도
- **Cyclomatic Complexity**: < 10
- **Function Length**: < 50 lines
- **File Length**: < 500 lines
- **Parameter Count**: < 5

### 테스트 커버리지
- **Line Coverage**: > 80%
- **Branch Coverage**: > 75%
- **Function Coverage**: > 90%

### 성능 지표
- **Bundle Size**: < 1MB (gzipped)
- **Build Time**: < 30 seconds
- **Lint Time**: < 10 seconds

---

## 🎯 실행 계획

### 새 프로젝트 적용
1. ESLint/Prettier 설정
2. Pre-commit 훅 설정
3. 코드 리뷰 템플릿 생성
4. 팀 교육 세션 진행

### 기존 프로젝트 적용
1. 점진적 적용 계획 수립
2. 레거시 코드 리팩토링 우선순위 결정
3. 팀원별 역할 분담
4. 마이그레이션 가이드라인 작성

---

*마지막 업데이트: 2024-09*
*문서 담당: Frontend Team*