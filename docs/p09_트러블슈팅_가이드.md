# P09. 트러블슈팅 가이드

## 📋 개요

JOBER 프로젝트 개발 및 운영 중 발생할 수 있는 문제들과 해결 방법을 체계적으로 정리한 트러블슈팅 가이드입니다.

### 목적
- 자주 발생하는 문제들의 빠른 해결 방법 제시
- 문제 진단을 위한 체계적인 접근법 제공
- 개발팀의 문제 해결 효율성 향상
- 운영 중 장애 대응 가이드라인 제공

## 🚨 긴급 상황 대응

### 1. 애플리케이션 크래시

#### 증상
- 브라우저에서 빈 화면 표시
- 콘솔에 JavaScript 에러 메시지
- 페이지가 로딩되지 않음

#### 즉시 대응 방법
```bash
# 1. 개발 서버 재시작
npm run dev

# 2. 의존성 재설치
rm -rf node_modules package-lock.json
npm install

# 3. 캐시 클리어
npm run build --clean
```

#### 근본 원인 분석
```javascript
// 브라우저 콘솔에서 확인
console.error('Error details:', error);

// React Error Boundary 구현
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);

    // 에러 리포팅 서비스로 전송
    this.reportError(error, errorInfo);
  }

  reportError = (error, errorInfo) => {
    // Sentry, LogRocket 등으로 에러 전송
    if (window.gtag) {
      window.gtag('event', 'exception', {
        description: error.toString(),
        fatal: false
      });
    }
  };

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-fallback">
          <h2>문제가 발생했습니다</h2>
          <button onClick={() => window.location.reload()}>
            페이지 새로고침
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

### 2. API 서버 연결 실패

#### 증상
- "네트워크 오류" 메시지 표시
- 템플릿 생성/조회 기능 작동 안 함
- 로그인/회원가입 실패

#### 즉시 대응 방법
```javascript
// API 연결 상태 확인
const checkApiHealth = async () => {
  try {
    const response = await fetch('/api/health');
    if (response.ok) {
      console.log('API 서버 정상');
    } else {
      console.error('API 서버 응답 이상:', response.status);
    }
  } catch (error) {
    console.error('API 서버 연결 실패:', error);
  }
};

// 자동 재시도 로직
const apiWithRetry = async (url, options, maxRetries = 3) => {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      if (response.ok) return response;

      if (i === maxRetries - 1) throw new Error(`API 호출 실패: ${response.status}`);

      // 지수 백오프
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
    }
  }
};
```

## 🔧 개발 환경 문제

### 1. 개발 서버 시작 실패

#### 문제: "EADDRINUSE: address already in use"
```bash
# 해결 방법 1: 다른 포트 사용
npm run dev -- --port 5174

# 해결 방법 2: 기존 프로세스 종료 (Windows)
netstat -ano | findstr :5173
taskkill /PID <PID번호> /F

# 해결 방법 3: 기존 프로세스 종료 (macOS/Linux)
lsof -ti:5173 | xargs kill -9
```

#### 문제: "Module not found" 에러
```bash
# 1. 의존성 재설치
rm -rf node_modules package-lock.json
npm install

# 2. 캐시 클리어
npm cache clean --force

# 3. Node.js 버전 확인
node --version  # 18.x 이상 권장
```

#### 문제: HMR (Hot Module Replacement) 작동 안 함
```javascript
// vite.config.js 설정 확인
export default defineConfig({
  plugins: [react()],
  server: {
    hmr: {
      overlay: true
    },
    host: true,
    port: 5173
  }
});
```

### 2. 빌드 실패

#### 문제: TypeScript 에러
```bash
# TypeScript 확인
npx tsc --noEmit

# 일반적인 해결 방법
# 1. 타입 정의 확인
npm install --save-dev @types/react @types/react-dom

# 2. tsconfig.json 설정 확인
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  }
}
```

#### 문제: 메모리 부족 에러
```bash
# 메모리 한도 증가
NODE_OPTIONS="--max-old-space-size=4096" npm run build

# package.json에 설정 추가
{
  "scripts": {
    "build": "NODE_OPTIONS=\"--max-old-space-size=4096\" vite build"
  }
}
```

### 3. ESLint 및 Prettier 설정 문제

#### ESLint 규칙 충돌
```javascript
// .eslintrc.js 설정 수정
module.exports = {
  extends: [
    'eslint:recommended',
    '@typescript-eslint/recommended',
    'plugin:react/recommended',
    'plugin:react-hooks/recommended',
    'prettier' // Prettier와 충돌하는 규칙 비활성화
  ],
  rules: {
    'react/react-in-jsx-scope': 'off', // React 17+에서는 불필요
    'react/prop-types': 'off', // TypeScript 사용 시 불필요
    '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }]
  }
};
```

#### Prettier 포맷팅 문제
```json
// .prettierrc 설정
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false
}
```

## 🌐 브라우저 호환성 문제

### 1. Internet Explorer 지원 문제

#### Polyfill 추가
```javascript
// main.jsx에 polyfill 추가
import 'core-js/stable';
import 'regenerator-runtime/runtime';

// 또는 Vite 설정에서 대상 브라우저 지정
// vite.config.js
export default defineConfig({
  build: {
    target: ['es2015', 'edge88', 'firefox78', 'chrome87', 'safari14']
  }
});
```

### 2. Safari 관련 문제

#### 날짜 파싱 문제
```javascript
// 잘못된 방법 (Safari에서 NaN 반환)
const date = new Date('2024-01-01');

// 올바른 방법
const date = new Date('2024/01/01');

// 더 안전한 방법
const parseDate = (dateString) => {
  const [year, month, day] = dateString.split('-');
  return new Date(year, month - 1, day);
};
```

#### CSS Grid 문제
```css
/* Safari에서 grid-gap 대신 gap 사용 */
.grid-container {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 1rem; /* grid-gap 대신 gap 사용 */
}
```

### 3. 모바일 브라우저 문제

#### 뷰포트 높이 문제
```css
/* iOS Safari의 100vh 문제 해결 */
.full-height {
  height: 100vh;
  height: -webkit-fill-available;
}

html {
  height: -webkit-fill-available;
}
```

#### 터치 이벤트 문제
```javascript
// 터치와 마우스 이벤트 모두 처리
const handleInteraction = (e) => {
  e.preventDefault();
  // 터치 이벤트 처리
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;

  // 로직 처리
};

<div
  onMouseDown={handleInteraction}
  onTouchStart={handleInteraction}
  style={{ touchAction: 'none' }} // 스크롤 방지
>
  Content
</div>
```

## 📱 모바일 대응 문제

### 1. 반응형 레이아웃 문제

#### 브레이크포인트 불일치
```css
/* Tailwind CSS 브레이크포인트 재정의 */
@media (max-width: 639px) {
  /* 모바일 */
}

@media (min-width: 640px) and (max-width: 1023px) {
  /* 태블릿 */
}

@media (min-width: 1024px) {
  /* 데스크톱 */
}
```

#### 모바일 메뉴 스크롤 문제
```javascript
// 모바일 메뉴 열릴 때 body 스크롤 방지
const toggleMobileMenu = (isOpen) => {
  if (isOpen) {
    document.body.style.overflow = 'hidden';
    document.body.style.height = '100%';
  } else {
    document.body.style.overflow = '';
    document.body.style.height = '';
  }
};

// useEffect로 정리
useEffect(() => {
  return () => {
    document.body.style.overflow = '';
    document.body.style.height = '';
  };
}, []);
```

### 2. 터치 UX 문제

#### 버튼 크기 부족
```css
/* 최소 터치 타겟 크기 44px */
.touch-target {
  min-height: 44px;
  min-width: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
}
```

#### 호버 효과 문제
```css
/* 터치 디바이스에서 호버 효과 제거 */
@media (hover: hover) {
  .button:hover {
    background-color: #blue-600;
  }
}

/* 또는 JavaScript로 터치 디바이스 감지 */
.button:not(.touch-device):hover {
  background-color: #blue-600;
}
```

## 🔐 인증 및 보안 문제

### 1. 토큰 만료 문제

#### 자동 토큰 갱신
```javascript
// API 인터셉터로 토큰 갱신 처리
const apiClient = axios.create({
  baseURL: '/api'
});

apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        const refreshToken = localStorage.getItem('refreshToken');
        const response = await axios.post('/api/auth/refresh', {
          refreshToken
        });

        const { accessToken } = response.data;
        localStorage.setItem('accessToken', accessToken);

        // 원래 요청 재시도
        originalRequest.headers.Authorization = `Bearer ${accessToken}`;
        return apiClient(originalRequest);
      } catch (refreshError) {
        // 리프레시 실패 시 로그아웃
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);
```

### 2. CORS 문제

#### 개발 환경 CORS 설정
```javascript
// vite.config.js
export default defineConfig({
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        secure: false
      }
    }
  }
});
```

#### 프로덕션 CORS 문제
```javascript
// 서버 측에서 CORS 헤더 설정 확인
const corsOptions = {
  origin: ['https://yourdomain.com', 'https://www.yourdomain.com'],
  credentials: true,
  optionsSuccessStatus: 200
};
```

## 🎨 스타일링 문제

### 1. Tailwind CSS 문제

#### 클래스 적용 안 됨
```javascript
// 동적 클래스 생성 시 safelist 사용
// tailwind.config.js
module.exports = {
  content: ['./src/**/*.{js,jsx,ts,tsx}'],
  safelist: [
    'bg-blue-500',
    'bg-red-500',
    'bg-green-500',
    // 동적으로 생성되는 클래스들
  ]
};

// 또는 전체 클래스명 사용
const getButtonColor = (color) => {
  const colors = {
    blue: 'bg-blue-500 hover:bg-blue-600',
    red: 'bg-red-500 hover:bg-red-600',
    green: 'bg-green-500 hover:bg-green-600'
  };
  return colors[color] || colors.blue;
};
```

#### 스타일 우선순위 문제
```css
/* !important 대신 구체성 증가 */
.pricing-card.featured {
  @apply border-2 border-orange-500 shadow-lg;
}

/* 또는 레이어 사용 */
@layer components {
  .custom-button {
    @apply px-4 py-2 bg-blue-500 text-white rounded;
  }
}
```

### 2. CSS-in-JS 문제

#### 스타일 플리커링
```javascript
// Styled Components에서 SSR 설정
import { ServerStyleSheet } from 'styled-components';

// 또는 emotion의 경우
import { CacheProvider } from '@emotion/react';
import createCache from '@emotion/cache';

const cache = createCache({ key: 'css' });

function App() {
  return (
    <CacheProvider value={cache}>
      {/* 앱 컴포넌트 */}
    </CacheProvider>
  );
}
```

## 📊 성능 문제

### 1. 느린 렌더링

#### React DevTools Profiler 사용
```javascript
// 성능 프로파일링
import { Profiler } from 'react';

function onRenderCallback(id, phase, actualDuration) {
  console.log('Component:', id, 'Phase:', phase, 'Duration:', actualDuration);
}

<Profiler id="PricingCard" onRender={onRenderCallback}>
  <PricingCard />
</Profiler>
```

#### 메모이제이션 최적화
```javascript
// 불필요한 리렌더링 방지
const ExpensiveComponent = memo(({ data, onUpdate }) => {
  const processedData = useMemo(() => {
    return data.map(item => ({
      ...item,
      processed: heavyCalculation(item)
    }));
  }, [data]);

  const handleUpdate = useCallback((id) => {
    onUpdate(id);
  }, [onUpdate]);

  return (
    <div>
      {processedData.map(item => (
        <Item key={item.id} data={item} onUpdate={handleUpdate} />
      ))}
    </div>
  );
});
```

### 2. 번들 크기 문제

#### 동적 임포트 사용
```javascript
// 라우트 레벨 코드 스플리팅
const DashboardPage = lazy(() => import('./pages/DashboardPage'));
const TemplatesPage = lazy(() => import('./pages/TemplatesPage'));

// 컴포넌트 레벨 코드 스플리팅
const HeavyChart = lazy(() => import('./components/HeavyChart'));

function App() {
  return (
    <Suspense fallback={<div>로딩 중...</div>}>
      <Routes>
        <Route path="/dashboard" element={<DashboardPage />} />
        <Route path="/templates" element={<TemplatesPage />} />
      </Routes>
    </Suspense>
  );
}
```

#### 라이브러리 최적화
```javascript
// 트리 셰이킹을 위한 개별 임포트
import { debounce } from 'lodash-es';
// 대신에
import debounce from 'lodash/debounce';

// 날짜 라이브러리 최적화
import { format } from 'date-fns';
// 대신에
import format from 'date-fns/format';
```

## 🔍 디버깅 도구 및 방법

### 1. React DevTools 활용

#### 컴포넌트 디버깅
```javascript
// 개발 환경에서만 디버그 정보 출력
if (process.env.NODE_ENV === 'development') {
  console.log('Props:', props);
  console.log('State:', state);
}

// 조건부 디버깅
const DEBUG = process.env.NODE_ENV === 'development' && window.location.search.includes('debug=true');

if (DEBUG) {
  console.group('Component Debug Info');
  console.log('Props:', props);
  console.log('State:', state);
  console.groupEnd();
}
```

### 2. 네트워크 디버깅

#### API 호출 로깅
```javascript
// API 호출 래퍼
const apiLogger = (originalFetch) => {
  return async (...args) => {
    const [url, options] = args;

    console.group(`🌐 API Call: ${options?.method || 'GET'} ${url}`);
    console.log('Request:', options);

    try {
      const response = await originalFetch(...args);
      const clonedResponse = response.clone();
      const data = await clonedResponse.json();

      console.log('Response:', { status: response.status, data });
      console.groupEnd();

      return response;
    } catch (error) {
      console.error('Error:', error);
      console.groupEnd();
      throw error;
    }
  };
};

// 개발 환경에서만 적용
if (process.env.NODE_ENV === 'development') {
  window.fetch = apiLogger(window.fetch);
}
```

### 3. 상태 관리 디버깅

#### Zustand 디버깅
```javascript
import { devtools } from 'zustand/middleware';

const useTemplateStore = create(
  devtools(
    (set, get) => ({
      templates: [],
      loading: false,
      error: null,

      fetchTemplates: async () => {
        set({ loading: true, error: null }, false, 'fetchTemplates/start');

        try {
          const templates = await api.fetchTemplates();
          set({ templates, loading: false }, false, 'fetchTemplates/success');
        } catch (error) {
          set({ error: error.message, loading: false }, false, 'fetchTemplates/error');
        }
      }
    }),
    {
      name: 'template-store' // Redux DevTools에 표시될 이름
    }
  )
);
```

## 📋 체크리스트 및 예방법

### 1. 개발 전 체크리스트

#### 환경 설정 확인
- [ ] Node.js 버전 18.x 이상
- [ ] npm 또는 yarn 최신 버전
- [ ] Git 설정 완료
- [ ] IDE 확장 프로그램 설치 (ESLint, Prettier)
- [ ] 환경 변수 파일(.env) 설정

#### 코드 품질 도구 설정
- [ ] ESLint 규칙 설정
- [ ] Prettier 포맷팅 설정
- [ ] Pre-commit 훅 설정
- [ ] TypeScript 설정 (필요한 경우)

### 2. 커밋 전 체크리스트

```bash
# 자동화된 품질 검사
npm run lint          # ESLint 검사
npm run format        # Prettier 포맷팅
npm run test          # 테스트 실행
npm run build         # 빌드 확인
```

### 3. 배포 전 체크리스트

#### 기능 테스트
- [ ] 핵심 사용자 플로우 테스트
- [ ] 다양한 브라우저에서 테스트
- [ ] 모바일 디바이스 테스트
- [ ] 네트워크 연결 불안정 상황 테스트

#### 성능 검사
- [ ] Lighthouse 점수 확인
- [ ] 번들 크기 분석
- [ ] 로딩 시간 측정
- [ ] 메모리 사용량 확인

## 🆘 긴급 상황 대응 매뉴얼

### 1. 서비스 다운 시

#### 즉시 대응 (5분 이내)
1. **상황 파악**: 에러 로그 확인
2. **임시 조치**: 이전 버전으로 롤백
3. **커뮤니케이션**: 관련자에게 상황 전파

#### 원인 분석 (30분 이내)
1. **로그 분석**: 서버 및 클라이언트 로그 확인
2. **재현 테스트**: 문제 상황 재현
3. **영향 범위**: 어떤 기능이 영향을 받았는지 파악

### 2. 에러 모니터링 설정

#### Sentry 연동
```javascript
import * as Sentry from '@sentry/react';

Sentry.init({
  dsn: process.env.REACT_APP_SENTRY_DSN,
  environment: process.env.NODE_ENV,
  integrations: [
    new Sentry.BrowserTracing(),
  ],
  tracesSampleRate: 1.0,
});

// 에러 캐치 및 리포팅
const reportError = (error, errorInfo) => {
  Sentry.withScope((scope) => {
    scope.setContext('errorInfo', errorInfo);
    Sentry.captureException(error);
  });
};
```

## 📞 지원 및 문의

### 내부 지원
- **개발팀 Slack**: #dev-frontend
- **긴급 상황**: 개발 리드에게 직접 연락
- **문서 업데이트**: GitHub Issues 활용

### 외부 리소스
- **React 공식 문서**: https://reactjs.org/docs
- **Vite 문서**: https://vitejs.dev/guide/
- **Tailwind CSS**: https://tailwindcss.com/docs
- **Stack Overflow**: React 관련 질문 검색

## 🔄 문서 업데이트

### 새로운 문제 발견 시
1. 문제 상황과 해결 방법 문서화
2. 이 가이드에 추가
3. 팀원들과 공유
4. 정기적으로 문서 업데이트

### 개선 사항 제안
- GitHub Issues를 통한 개선 사항 제안
- 월간 회고를 통한 문서 검토
- 신규 팀원 피드백 수집

---

이 트러블슈팅 가이드는 JOBER 프로젝트의 안정적인 개발과 운영을 위한 핵심 자료입니다. 새로운 문제가 발생할 때마다 이 문서를 업데이트하여 팀의 문제 해결 능력을 지속적으로 향상시켜 나가겠습니다.

> 📅 **문서 버전**: v1.0
> 📅 **최종 수정일**: 2024-12-29
> 👥 **작성자**: Team 3 Frontend Development Team